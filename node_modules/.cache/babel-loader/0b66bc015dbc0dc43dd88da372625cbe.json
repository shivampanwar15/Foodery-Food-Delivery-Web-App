{"ast":null,"code":"\"use strict\";\n\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar _regeneratorRuntime = require(\"/Users/shivampanwar/Desktop/GoFood/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\nvar _asyncToGenerator = require(\"/Users/shivampanwar/Desktop/GoFood/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\nvar _classCallCheck = require(\"/Users/shivampanwar/Desktop/GoFood/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/Users/shivampanwar/Desktop/GoFood/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"/Users/shivampanwar/Desktop/GoFood/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"/Users/shivampanwar/Desktop/GoFood/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"/Users/shivampanwar/Desktop/GoFood/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AwsClient = void 0;\nvar awsrequestsigner_1 = require(\"./awsrequestsigner\");\nvar baseexternalclient_1 = require(\"./baseexternalclient\");\n/**\n * AWS external account client. This is used for AWS workloads, where\n * AWS STS GetCallerIdentity serialized signed requests are exchanged for\n * GCP access token.\n */\nvar AwsClient = /*#__PURE__*/function (_baseexternalclient_) {\n  _inherits(AwsClient, _baseexternalclient_);\n  /**\n   * Instantiates an AwsClient instance using the provided JSON\n   * object loaded from an external account credentials file.\n   * An error is thrown if the credential is not a valid AWS credential.\n   * @param options The external account options object typically loaded\n   *   from the external account JSON credential file.\n   * @param additionalOptions Optional additional behavior customization\n   *   options. These currently customize expiration threshold time and\n   *   whether to retry on 401/403 API request errors.\n   */\n  function AwsClient(options, additionalOptions) {\n    var _this;\n    _classCallCheck(this, AwsClient);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(AwsClient).call(this, options, additionalOptions));\n    _this.environmentId = options.credential_source.environment_id;\n    // This is only required if the AWS region is not available in the\n    // AWS_REGION or AWS_DEFAULT_REGION environment variables.\n    _this.regionUrl = options.credential_source.region_url;\n    // This is only required if AWS security credentials are not available in\n    // environment variables.\n    _this.securityCredentialsUrl = options.credential_source.url;\n    _this.regionalCredVerificationUrl = options.credential_source.regional_cred_verification_url;\n    _this.imdsV2SessionTokenUrl = options.credential_source.imdsv2_session_token_url;\n    _this.awsRequestSigner = null;\n    _this.region = '';\n    // data validators\n    _this.validateEnvironmentId();\n    _this.validateMetadataServerURLs();\n    return _this;\n  }\n  _createClass(AwsClient, [{\n    key: \"validateEnvironmentId\",\n    value: function validateEnvironmentId() {\n      var _a;\n      var match = (_a = this.environmentId) === null || _a === void 0 ? void 0 : _a.match(/^(aws)(\\d+)$/);\n      if (!match || !this.regionalCredVerificationUrl) {\n        throw new Error('No valid AWS \"credential_source\" provided');\n      } else if (parseInt(match[2], 10) !== 1) {\n        throw new Error(\"aws version \\\"\".concat(match[2], \"\\\" is not supported in the current build.\"));\n      }\n    }\n  }, {\n    key: \"validateMetadataServerURLs\",\n    value: function validateMetadataServerURLs() {\n      this.validateMetadataURL(this.regionUrl, 'region_url');\n      this.validateMetadataURL(this.securityCredentialsUrl, 'url');\n      this.validateMetadataURL(this.imdsV2SessionTokenUrl, 'imdsv2_session_token_url');\n    }\n  }, {\n    key: \"validateMetadataURL\",\n    value: function validateMetadataURL(value, prop) {\n      if (!value) return;\n      var url = new URL(value);\n      if (url.hostname !== AwsClient.AWS_EC2_METADATA_IPV4_ADDRESS && url.hostname !== \"[\".concat(AwsClient.AWS_EC2_METADATA_IPV6_ADDRESS, \"]\")) {\n        throw new RangeError(\"Invalid host \\\"\".concat(url.hostname, \"\\\" for \\\"\").concat(prop, \"\\\". Expecting \").concat(AwsClient.AWS_EC2_METADATA_IPV4_ADDRESS, \" or \").concat(AwsClient.AWS_EC2_METADATA_IPV6_ADDRESS, \".\"));\n      }\n    }\n    /**\n     * Triggered when an external subject token is needed to be exchanged for a\n     * GCP access token via GCP STS endpoint.\n     * This uses the `options.credential_source` object to figure out how\n     * to retrieve the token using the current environment. In this case,\n     * this uses a serialized AWS signed request to the STS GetCallerIdentity\n     * endpoint.\n     * The logic is summarized as:\n     * 1. If imdsv2_session_token_url is provided in the credential source, then\n     *    fetch the aws session token and include it in the headers of the\n     *    metadata requests. This is a requirement for IDMSv2 but optional\n     *    for IDMSv1.\n     * 2. Retrieve AWS region from availability-zone.\n     * 3a. Check AWS credentials in environment variables. If not found, get\n     *     from security-credentials endpoint.\n     * 3b. Get AWS credentials from security-credentials endpoint. In order\n     *     to retrieve this, the AWS role needs to be determined by calling\n     *     security-credentials endpoint without any argument. Then the\n     *     credentials can be retrieved via: security-credentials/role_name\n     * 4. Generate the signed request to AWS STS GetCallerIdentity action.\n     * 5. Inject x-goog-cloud-target-resource into header and serialize the\n     *    signed request. This will be the subject-token to pass to GCP STS.\n     * @return A promise that resolves with the external subject token.\n     */\n  }, {\n    key: \"retrieveSubjectToken\",\n    value: function () {\n      var _retrieveSubjectToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _this2 = this;\n        var metadataHeaders, options, reformattedHeader, extendedHeaders, key;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (this.awsRequestSigner) {\n                _context2.next = 10;\n                break;\n              }\n              metadataHeaders = {};\n              if (!this.imdsV2SessionTokenUrl) {\n                _context2.next = 6;\n                break;\n              }\n              _context2.next = 5;\n              return this.getImdsV2SessionToken();\n            case 5:\n              metadataHeaders['x-aws-ec2-metadata-token'] = _context2.sent;\n            case 6:\n              _context2.next = 8;\n              return this.getAwsRegion(metadataHeaders);\n            case 8:\n              this.region = _context2.sent;\n              this.awsRequestSigner = new awsrequestsigner_1.AwsRequestSigner( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n                var roleName, awsCreds;\n                return _regeneratorRuntime.wrap(function _callee$(_context) {\n                  while (1) switch (_context.prev = _context.next) {\n                    case 0:\n                      if (!(process.env['AWS_ACCESS_KEY_ID'] && process.env['AWS_SECRET_ACCESS_KEY'])) {\n                        _context.next = 2;\n                        break;\n                      }\n                      return _context.abrupt(\"return\", {\n                        accessKeyId: process.env['AWS_ACCESS_KEY_ID'],\n                        secretAccessKey: process.env['AWS_SECRET_ACCESS_KEY'],\n                        // This is normally not available for permanent credentials.\n                        token: process.env['AWS_SESSION_TOKEN']\n                      });\n                    case 2:\n                      _context.next = 4;\n                      return _this2.getAwsRoleName(metadataHeaders);\n                    case 4:\n                      roleName = _context.sent;\n                      _context.next = 7;\n                      return _this2.getAwsSecurityCredentials(roleName, metadataHeaders);\n                    case 7:\n                      awsCreds = _context.sent;\n                      return _context.abrupt(\"return\", {\n                        accessKeyId: awsCreds.AccessKeyId,\n                        secretAccessKey: awsCreds.SecretAccessKey,\n                        token: awsCreds.Token\n                      });\n                    case 9:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }, _callee);\n              })), this.region);\n            case 10:\n              _context2.next = 12;\n              return this.awsRequestSigner.getRequestOptions({\n                url: this.regionalCredVerificationUrl.replace('{region}', this.region),\n                method: 'POST'\n              });\n            case 12:\n              options = _context2.sent;\n              // The GCP STS endpoint expects the headers to be formatted as:\n              // [\n              //   {key: 'x-amz-date', value: '...'},\n              //   {key: 'Authorization', value: '...'},\n              //   ...\n              // ]\n              // And then serialized as:\n              // encodeURIComponent(JSON.stringify({\n              //   url: '...',\n              //   method: 'POST',\n              //   headers: [{key: 'x-amz-date', value: '...'}, ...]\n              // }))\n              reformattedHeader = [];\n              extendedHeaders = Object.assign({\n                // The full, canonical resource name of the workload identity pool\n                // provider, with or without the HTTPS prefix.\n                // Including this header as part of the signature is recommended to\n                // ensure data integrity.\n                'x-goog-cloud-target-resource': this.audience\n              }, options.headers); // Reformat header to GCP STS expected format.\n              for (key in extendedHeaders) {\n                reformattedHeader.push({\n                  key: key,\n                  value: extendedHeaders[key]\n                });\n              }\n              // Serialize the reformatted signed request.\n              return _context2.abrupt(\"return\", encodeURIComponent(JSON.stringify({\n                url: options.url,\n                method: options.method,\n                headers: reformattedHeader\n              })));\n            case 17:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function retrieveSubjectToken() {\n        return _retrieveSubjectToken.apply(this, arguments);\n      }\n      return retrieveSubjectToken;\n    }()\n    /**\n     * @return A promise that resolves with the IMDSv2 Session Token.\n     */\n  }, {\n    key: \"getImdsV2SessionToken\",\n    value: function () {\n      var _getImdsV2SessionToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var opts, response;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              opts = {\n                url: this.imdsV2SessionTokenUrl,\n                method: 'PUT',\n                responseType: 'text',\n                headers: {\n                  'x-aws-ec2-metadata-token-ttl-seconds': '300'\n                }\n              };\n              _context3.next = 3;\n              return this.transporter.request(opts);\n            case 3:\n              response = _context3.sent;\n              return _context3.abrupt(\"return\", response.data);\n            case 5:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function getImdsV2SessionToken() {\n        return _getImdsV2SessionToken.apply(this, arguments);\n      }\n      return getImdsV2SessionToken;\n    }()\n    /**\n     * @param headers The headers to be used in the metadata request.\n     * @return A promise that resolves with the current AWS region.\n     */\n  }, {\n    key: \"getAwsRegion\",\n    value: function () {\n      var _getAwsRegion = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(headers) {\n        var opts, response;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              if (!(process.env['AWS_REGION'] || process.env['AWS_DEFAULT_REGION'])) {\n                _context4.next = 2;\n                break;\n              }\n              return _context4.abrupt(\"return\", process.env['AWS_REGION'] || process.env['AWS_DEFAULT_REGION']);\n            case 2:\n              if (this.regionUrl) {\n                _context4.next = 4;\n                break;\n              }\n              throw new Error('Unable to determine AWS region due to missing ' + '\"options.credential_source.region_url\"');\n            case 4:\n              opts = {\n                url: this.regionUrl,\n                method: 'GET',\n                responseType: 'text',\n                headers: headers\n              };\n              _context4.next = 7;\n              return this.transporter.request(opts);\n            case 7:\n              response = _context4.sent;\n              return _context4.abrupt(\"return\", response.data.substr(0, response.data.length - 1));\n            case 9:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function getAwsRegion(_x) {\n        return _getAwsRegion.apply(this, arguments);\n      }\n      return getAwsRegion;\n    }()\n    /**\n     * @param headers The headers to be used in the metadata request.\n     * @return A promise that resolves with the assigned role to the current\n     *   AWS VM. This is needed for calling the security-credentials endpoint.\n     */\n  }, {\n    key: \"getAwsRoleName\",\n    value: function () {\n      var _getAwsRoleName = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(headers) {\n        var opts, response;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              if (this.securityCredentialsUrl) {\n                _context5.next = 2;\n                break;\n              }\n              throw new Error('Unable to determine AWS role name due to missing ' + '\"options.credential_source.url\"');\n            case 2:\n              opts = {\n                url: this.securityCredentialsUrl,\n                method: 'GET',\n                responseType: 'text',\n                headers: headers\n              };\n              _context5.next = 5;\n              return this.transporter.request(opts);\n            case 5:\n              response = _context5.sent;\n              return _context5.abrupt(\"return\", response.data);\n            case 7:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function getAwsRoleName(_x2) {\n        return _getAwsRoleName.apply(this, arguments);\n      }\n      return getAwsRoleName;\n    }()\n    /**\n     * Retrieves the temporary AWS credentials by calling the security-credentials\n     * endpoint as specified in the `credential_source` object.\n     * @param roleName The role attached to the current VM.\n     * @param headers The headers to be used in the metadata request.\n     * @return A promise that resolves with the temporary AWS credentials\n     *   needed for creating the GetCallerIdentity signed request.\n     */\n  }, {\n    key: \"getAwsSecurityCredentials\",\n    value: function () {\n      var _getAwsSecurityCredentials = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(roleName, headers) {\n        var response;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              _context6.next = 2;\n              return this.transporter.request({\n                url: \"\".concat(this.securityCredentialsUrl, \"/\").concat(roleName),\n                responseType: 'json',\n                headers: headers\n              });\n            case 2:\n              response = _context6.sent;\n              return _context6.abrupt(\"return\", response.data);\n            case 4:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n      function getAwsSecurityCredentials(_x3, _x4) {\n        return _getAwsSecurityCredentials.apply(this, arguments);\n      }\n      return getAwsSecurityCredentials;\n    }()\n  }]);\n  return AwsClient;\n}(baseexternalclient_1.BaseExternalAccountClient);\nexports.AwsClient = AwsClient;\nAwsClient.AWS_EC2_METADATA_IPV4_ADDRESS = '169.254.169.254';\nAwsClient.AWS_EC2_METADATA_IPV6_ADDRESS = 'fd00:ec2::254';","map":null,"metadata":{},"sourceType":"script"}