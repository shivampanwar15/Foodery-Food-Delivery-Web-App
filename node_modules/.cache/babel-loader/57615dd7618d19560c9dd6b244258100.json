{"ast":null,"code":"\"use strict\";\n\n// Copyright 2013 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar _regeneratorRuntime = require(\"/Users/shivampanwar/Desktop/GoFood/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\nvar _asyncToGenerator = require(\"/Users/shivampanwar/Desktop/GoFood/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\nvar _classCallCheck = require(\"/Users/shivampanwar/Desktop/GoFood/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/Users/shivampanwar/Desktop/GoFood/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"/Users/shivampanwar/Desktop/GoFood/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"/Users/shivampanwar/Desktop/GoFood/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"/Users/shivampanwar/Desktop/GoFood/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Compute = void 0;\nvar arrify = require(\"arrify\");\nvar gaxios_1 = require(\"gaxios\");\nvar gcpMetadata = require(\"gcp-metadata\");\nvar oauth2client_1 = require(\"./oauth2client\");\nvar Compute = /*#__PURE__*/function (_oauth2client_1$OAuth) {\n  _inherits(Compute, _oauth2client_1$OAuth);\n  /**\n   * Google Compute Engine service account credentials.\n   *\n   * Retrieve access token from the metadata server.\n   * See: https://developers.google.com/compute/docs/authentication\n   */\n  function Compute() {\n    var _this;\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, Compute);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Compute).call(this, options));\n    // Start with an expired refresh token, which will automatically be\n    // refreshed before the first API call is made.\n    _this.credentials = {\n      expiry_date: 1,\n      refresh_token: 'compute-placeholder'\n    };\n    _this.serviceAccountEmail = options.serviceAccountEmail || 'default';\n    _this.scopes = arrify(options.scopes);\n    return _this;\n  }\n  /**\n   * Refreshes the access token.\n   * @param refreshToken Unused parameter\n   */\n  _createClass(Compute, [{\n    key: \"refreshTokenNoCache\",\n    value: function () {\n      var _refreshTokenNoCache = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      refreshToken) {\n        var tokenPath, data, instanceOptions, tokens;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              tokenPath = \"service-accounts/\".concat(this.serviceAccountEmail, \"/token\");\n              _context.prev = 1;\n              instanceOptions = {\n                property: tokenPath\n              };\n              if (this.scopes.length > 0) {\n                instanceOptions.params = {\n                  scopes: this.scopes.join(',')\n                };\n              }\n              _context.next = 6;\n              return gcpMetadata.instance(instanceOptions);\n            case 6:\n              data = _context.sent;\n              _context.next = 13;\n              break;\n            case 9:\n              _context.prev = 9;\n              _context.t0 = _context[\"catch\"](1);\n              if (_context.t0 instanceof gaxios_1.GaxiosError) {\n                _context.t0.message = \"Could not refresh access token: \".concat(_context.t0.message);\n                this.wrapError(_context.t0);\n              }\n              throw _context.t0;\n            case 13:\n              tokens = data;\n              if (data && data.expires_in) {\n                tokens.expiry_date = new Date().getTime() + data.expires_in * 1000;\n                delete tokens.expires_in;\n              }\n              this.emit('tokens', tokens);\n              return _context.abrupt(\"return\", {\n                tokens: tokens,\n                res: null\n              });\n            case 17:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[1, 9]]);\n      }));\n      function refreshTokenNoCache(_x) {\n        return _refreshTokenNoCache.apply(this, arguments);\n      }\n      return refreshTokenNoCache;\n    }()\n    /**\n     * Fetches an ID token.\n     * @param targetAudience the audience for the fetched ID token.\n     */\n  }, {\n    key: \"fetchIdToken\",\n    value: function () {\n      var _fetchIdToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(targetAudience) {\n        var idTokenPath, idToken, instanceOptions;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              idTokenPath = \"service-accounts/\".concat(this.serviceAccountEmail, \"/identity\") + \"?format=full&audience=\".concat(targetAudience);\n              _context2.prev = 1;\n              instanceOptions = {\n                property: idTokenPath\n              };\n              _context2.next = 5;\n              return gcpMetadata.instance(instanceOptions);\n            case 5:\n              idToken = _context2.sent;\n              _context2.next = 12;\n              break;\n            case 8:\n              _context2.prev = 8;\n              _context2.t0 = _context2[\"catch\"](1);\n              if (_context2.t0 instanceof Error) {\n                _context2.t0.message = \"Could not fetch ID token: \".concat(_context2.t0.message);\n              }\n              throw _context2.t0;\n            case 12:\n              return _context2.abrupt(\"return\", idToken);\n            case 13:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this, [[1, 8]]);\n      }));\n      function fetchIdToken(_x2) {\n        return _fetchIdToken.apply(this, arguments);\n      }\n      return fetchIdToken;\n    }()\n  }, {\n    key: \"wrapError\",\n    value: function wrapError(e) {\n      var res = e.response;\n      if (res && res.status) {\n        e.code = res.status.toString();\n        if (res.status === 403) {\n          e.message = 'A Forbidden error was returned while attempting to retrieve an access ' + 'token for the Compute Engine built-in service account. This may be because the Compute ' + 'Engine instance does not have the correct permission scopes specified: ' + e.message;\n        } else if (res.status === 404) {\n          e.message = 'A Not Found error was returned while attempting to retrieve an access' + 'token for the Compute Engine built-in service account. This may be because the Compute ' + 'Engine instance does not have any permission scopes specified: ' + e.message;\n        }\n      }\n    }\n  }]);\n  return Compute;\n}(oauth2client_1.OAuth2Client);\nexports.Compute = Compute;","map":null,"metadata":{},"sourceType":"script"}