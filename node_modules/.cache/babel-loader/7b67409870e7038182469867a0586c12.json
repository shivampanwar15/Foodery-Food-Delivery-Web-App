{"ast":null,"code":"\"use strict\";\n\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar _regeneratorRuntime = require(\"/Users/shivampanwar/Desktop/GoFood/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\nvar _asyncToGenerator = require(\"/Users/shivampanwar/Desktop/GoFood/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\nvar _classCallCheck = require(\"/Users/shivampanwar/Desktop/GoFood/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/Users/shivampanwar/Desktop/GoFood/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"/Users/shivampanwar/Desktop/GoFood/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"/Users/shivampanwar/Desktop/GoFood/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"/Users/shivampanwar/Desktop/GoFood/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OAuth2Client = exports.CertificateFormat = exports.CodeChallengeMethod = void 0;\nvar gaxios_1 = require(\"gaxios\");\nvar querystring = require(\"querystring\");\nvar stream = require(\"stream\");\nvar formatEcdsa = require(\"ecdsa-sig-formatter\");\nvar crypto_1 = require(\"../crypto/crypto\");\nvar authclient_1 = require(\"./authclient\");\nvar loginticket_1 = require(\"./loginticket\");\nvar CodeChallengeMethod;\n(function (CodeChallengeMethod) {\n  CodeChallengeMethod[\"Plain\"] = \"plain\";\n  CodeChallengeMethod[\"S256\"] = \"S256\";\n})(CodeChallengeMethod = exports.CodeChallengeMethod || (exports.CodeChallengeMethod = {}));\nvar CertificateFormat;\n(function (CertificateFormat) {\n  CertificateFormat[\"PEM\"] = \"PEM\";\n  CertificateFormat[\"JWK\"] = \"JWK\";\n})(CertificateFormat = exports.CertificateFormat || (exports.CertificateFormat = {}));\nvar OAuth2Client = /*#__PURE__*/function (_authclient_1$AuthCli) {\n  _inherits(OAuth2Client, _authclient_1$AuthCli);\n  function OAuth2Client(optionsOrClientId, clientSecret, redirectUri) {\n    var _this;\n    _classCallCheck(this, OAuth2Client);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(OAuth2Client).call(this));\n    _this.certificateCache = {};\n    _this.certificateExpiry = null;\n    _this.certificateCacheFormat = CertificateFormat.PEM;\n    _this.refreshTokenPromises = new Map();\n    var opts = optionsOrClientId && typeof optionsOrClientId === 'object' ? optionsOrClientId : {\n      clientId: optionsOrClientId,\n      clientSecret: clientSecret,\n      redirectUri: redirectUri\n    };\n    _this._clientId = opts.clientId;\n    _this._clientSecret = opts.clientSecret;\n    _this.redirectUri = opts.redirectUri;\n    _this.eagerRefreshThresholdMillis = opts.eagerRefreshThresholdMillis || 5 * 60 * 1000;\n    _this.forceRefreshOnFailure = !!opts.forceRefreshOnFailure;\n    return _this;\n  }\n  /**\n   * Generates URL for consent page landing.\n   * @param opts Options.\n   * @return URL to consent page.\n   */\n  _createClass(OAuth2Client, [{\n    key: \"generateAuthUrl\",\n    value: function generateAuthUrl() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      if (opts.code_challenge_method && !opts.code_challenge) {\n        throw new Error('If a code_challenge_method is provided, code_challenge must be included.');\n      }\n      opts.response_type = opts.response_type || 'code';\n      opts.client_id = opts.client_id || this._clientId;\n      opts.redirect_uri = opts.redirect_uri || this.redirectUri;\n      // Allow scopes to be passed either as array or a string\n      if (Array.isArray(opts.scope)) {\n        opts.scope = opts.scope.join(' ');\n      }\n      var rootUrl = OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\n      return rootUrl + '?' + querystring.stringify(opts);\n    }\n  }, {\n    key: \"generateCodeVerifier\",\n    value: function generateCodeVerifier() {\n      // To make the code compatible with browser SubtleCrypto we need to make\n      // this method async.\n      throw new Error('generateCodeVerifier is removed, please use generateCodeVerifierAsync instead.');\n    }\n    /**\n     * Convenience method to automatically generate a code_verifier, and its\n     * resulting SHA256. If used, this must be paired with a S256\n     * code_challenge_method.\n     *\n     * For a full example see:\n     * https://github.com/googleapis/google-auth-library-nodejs/blob/main/samples/oauth2-codeVerifier.js\n     */\n  }, {\n    key: \"generateCodeVerifierAsync\",\n    value: function () {\n      var _generateCodeVerifierAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var crypto, randomString, codeVerifier, unencodedCodeChallenge, codeChallenge;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              // base64 encoding uses 6 bits per character, and we want to generate128\n              // characters. 6*128/8 = 96.\n              crypto = (0, crypto_1.createCrypto)();\n              randomString = crypto.randomBytesBase64(96); // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\n              // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\n              // swapping out a few chars.\n              codeVerifier = randomString.replace(/\\+/g, '~').replace(/=/g, '_').replace(/\\//g, '-'); // Generate the base64 encoded SHA256\n              _context.next = 5;\n              return crypto.sha256DigestBase64(codeVerifier);\n            case 5:\n              unencodedCodeChallenge = _context.sent;\n              // We need to use base64UrlEncoding instead of standard base64\n              codeChallenge = unencodedCodeChallenge.split('=')[0].replace(/\\+/g, '-').replace(/\\//g, '_');\n              return _context.abrupt(\"return\", {\n                codeVerifier: codeVerifier,\n                codeChallenge: codeChallenge\n              });\n            case 8:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }));\n      function generateCodeVerifierAsync() {\n        return _generateCodeVerifierAsync.apply(this, arguments);\n      }\n      return generateCodeVerifierAsync;\n    }()\n  }, {\n    key: \"getToken\",\n    value: function getToken(codeOrOptions, callback) {\n      var options = typeof codeOrOptions === 'string' ? {\n        code: codeOrOptions\n      } : codeOrOptions;\n      if (callback) {\n        this.getTokenAsync(options).then(function (r) {\n          return callback(null, r.tokens, r.res);\n        }, function (e) {\n          return callback(e, null, e.response);\n        });\n      } else {\n        return this.getTokenAsync(options);\n      }\n    }\n  }, {\n    key: \"getTokenAsync\",\n    value: function () {\n      var _getTokenAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(options) {\n        var url, values, res, tokens;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n              values = {\n                code: options.code,\n                client_id: options.client_id || this._clientId,\n                client_secret: this._clientSecret,\n                redirect_uri: options.redirect_uri || this.redirectUri,\n                grant_type: 'authorization_code',\n                code_verifier: options.codeVerifier\n              };\n              _context2.next = 4;\n              return this.transporter.request({\n                method: 'POST',\n                url: url,\n                data: querystring.stringify(values),\n                headers: {\n                  'Content-Type': 'application/x-www-form-urlencoded'\n                }\n              });\n            case 4:\n              res = _context2.sent;\n              tokens = res.data;\n              if (res.data && res.data.expires_in) {\n                tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n                delete tokens.expires_in;\n              }\n              this.emit('tokens', tokens);\n              return _context2.abrupt(\"return\", {\n                tokens: tokens,\n                res: res\n              });\n            case 9:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function getTokenAsync(_x) {\n        return _getTokenAsync.apply(this, arguments);\n      }\n      return getTokenAsync;\n    }()\n    /**\n     * Refreshes the access token.\n     * @param refresh_token Existing refresh token.\n     * @private\n     */\n  }, {\n    key: \"refreshToken\",\n    value: function () {\n      var _refreshToken2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_refreshToken) {\n        var _this2 = this;\n        var p;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              if (_refreshToken) {\n                _context3.next = 2;\n                break;\n              }\n              return _context3.abrupt(\"return\", this.refreshTokenNoCache(_refreshToken));\n            case 2:\n              if (!this.refreshTokenPromises.has(_refreshToken)) {\n                _context3.next = 4;\n                break;\n              }\n              return _context3.abrupt(\"return\", this.refreshTokenPromises.get(_refreshToken));\n            case 4:\n              p = this.refreshTokenNoCache(_refreshToken).then(function (r) {\n                _this2.refreshTokenPromises.delete(_refreshToken);\n                return r;\n              }, function (e) {\n                _this2.refreshTokenPromises.delete(_refreshToken);\n                throw e;\n              });\n              this.refreshTokenPromises.set(_refreshToken, p);\n              return _context3.abrupt(\"return\", p);\n            case 7:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function refreshToken(_x2) {\n        return _refreshToken2.apply(this, arguments);\n      }\n      return refreshToken;\n    }()\n  }, {\n    key: \"refreshTokenNoCache\",\n    value: function () {\n      var _refreshTokenNoCache = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(refreshToken) {\n        var _a, url, data, res, tokens;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              if (refreshToken) {\n                _context4.next = 2;\n                break;\n              }\n              throw new Error('No refresh token is set.');\n            case 2:\n              url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n              data = {\n                refresh_token: refreshToken,\n                client_id: this._clientId,\n                client_secret: this._clientSecret,\n                grant_type: 'refresh_token'\n              };\n              _context4.prev = 4;\n              _context4.next = 7;\n              return this.transporter.request({\n                method: 'POST',\n                url: url,\n                data: querystring.stringify(data),\n                headers: {\n                  'Content-Type': 'application/x-www-form-urlencoded'\n                }\n              });\n            case 7:\n              res = _context4.sent;\n              _context4.next = 14;\n              break;\n            case 10:\n              _context4.prev = 10;\n              _context4.t0 = _context4[\"catch\"](4);\n              if (_context4.t0 instanceof gaxios_1.GaxiosError && _context4.t0.message === 'invalid_grant' && ((_a = _context4.t0.response) === null || _a === void 0 ? void 0 : _a.data) && /ReAuth/i.test(_context4.t0.response.data.error_description)) {\n                _context4.t0.message = JSON.stringify(_context4.t0.response.data);\n              }\n              throw _context4.t0;\n            case 14:\n              tokens = res.data; // TODO: de-duplicate this code from a few spots\n              if (res.data && res.data.expires_in) {\n                tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n                delete tokens.expires_in;\n              }\n              this.emit('tokens', tokens);\n              return _context4.abrupt(\"return\", {\n                tokens: tokens,\n                res: res\n              });\n            case 18:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this, [[4, 10]]);\n      }));\n      function refreshTokenNoCache(_x3) {\n        return _refreshTokenNoCache.apply(this, arguments);\n      }\n      return refreshTokenNoCache;\n    }()\n  }, {\n    key: \"refreshAccessToken\",\n    value: function refreshAccessToken(callback) {\n      if (callback) {\n        this.refreshAccessTokenAsync().then(function (r) {\n          return callback(null, r.credentials, r.res);\n        }, callback);\n      } else {\n        return this.refreshAccessTokenAsync();\n      }\n    }\n  }, {\n    key: \"refreshAccessTokenAsync\",\n    value: function () {\n      var _refreshAccessTokenAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        var r, tokens;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              _context5.next = 2;\n              return this.refreshToken(this.credentials.refresh_token);\n            case 2:\n              r = _context5.sent;\n              tokens = r.tokens;\n              tokens.refresh_token = this.credentials.refresh_token;\n              this.credentials = tokens;\n              return _context5.abrupt(\"return\", {\n                credentials: this.credentials,\n                res: r.res\n              });\n            case 7:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function refreshAccessTokenAsync() {\n        return _refreshAccessTokenAsync.apply(this, arguments);\n      }\n      return refreshAccessTokenAsync;\n    }()\n  }, {\n    key: \"getAccessToken\",\n    value: function getAccessToken(callback) {\n      if (callback) {\n        this.getAccessTokenAsync().then(function (r) {\n          return callback(null, r.token, r.res);\n        }, callback);\n      } else {\n        return this.getAccessTokenAsync();\n      }\n    }\n  }, {\n    key: \"getAccessTokenAsync\",\n    value: function () {\n      var _getAccessTokenAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        var shouldRefresh, refreshedAccessToken, r;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              shouldRefresh = !this.credentials.access_token || this.isTokenExpiring();\n              if (!shouldRefresh) {\n                _context6.next = 21;\n                break;\n              }\n              if (this.credentials.refresh_token) {\n                _context6.next = 13;\n                break;\n              }\n              if (!this.refreshHandler) {\n                _context6.next = 12;\n                break;\n              }\n              _context6.next = 6;\n              return this.processAndValidateRefreshHandler();\n            case 6:\n              refreshedAccessToken = _context6.sent;\n              if (!(refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token)) {\n                _context6.next = 10;\n                break;\n              }\n              this.setCredentials(refreshedAccessToken);\n              return _context6.abrupt(\"return\", {\n                token: this.credentials.access_token\n              });\n            case 10:\n              _context6.next = 13;\n              break;\n            case 12:\n              throw new Error('No refresh token or refresh handler callback is set.');\n            case 13:\n              _context6.next = 15;\n              return this.refreshAccessTokenAsync();\n            case 15:\n              r = _context6.sent;\n              if (!(!r.credentials || r.credentials && !r.credentials.access_token)) {\n                _context6.next = 18;\n                break;\n              }\n              throw new Error('Could not refresh access token.');\n            case 18:\n              return _context6.abrupt(\"return\", {\n                token: r.credentials.access_token,\n                res: r.res\n              });\n            case 21:\n              return _context6.abrupt(\"return\", {\n                token: this.credentials.access_token\n              });\n            case 22:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n      function getAccessTokenAsync() {\n        return _getAccessTokenAsync.apply(this, arguments);\n      }\n      return getAccessTokenAsync;\n    }()\n    /**\n     * The main authentication interface.  It takes an optional url which when\n     * present is the endpoint being accessed, and returns a Promise which\n     * resolves with authorization header fields.\n     *\n     * In OAuth2Client, the result has the form:\n     * { Authorization: 'Bearer <access_token_value>' }\n     * @param url The optional url being authorized\n     */\n  }, {\n    key: \"getRequestHeaders\",\n    value: function () {\n      var _getRequestHeaders = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(url) {\n        var headers;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              _context7.next = 2;\n              return this.getRequestMetadataAsync(url);\n            case 2:\n              headers = _context7.sent.headers;\n              return _context7.abrupt(\"return\", headers);\n            case 4:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this);\n      }));\n      function getRequestHeaders(_x4) {\n        return _getRequestHeaders.apply(this, arguments);\n      }\n      return getRequestHeaders;\n    }()\n  }, {\n    key: \"getRequestMetadataAsync\",\n    value: function () {\n      var _getRequestMetadataAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      url) {\n        var thisCreds, _headers, refreshedAccessToken, _headers2, r, tokens, e, credentials, headers;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              thisCreds = this.credentials;\n              if (!(!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey && !this.refreshHandler)) {\n                _context8.next = 3;\n                break;\n              }\n              throw new Error('No access, refresh token, API key or refresh handler callback is set.');\n            case 3:\n              if (!(thisCreds.access_token && !this.isTokenExpiring())) {\n                _context8.next = 7;\n                break;\n              }\n              thisCreds.token_type = thisCreds.token_type || 'Bearer';\n              _headers = {\n                Authorization: thisCreds.token_type + ' ' + thisCreds.access_token\n              };\n              return _context8.abrupt(\"return\", {\n                headers: this.addSharedMetadataHeaders(_headers)\n              });\n            case 7:\n              if (!this.refreshHandler) {\n                _context8.next = 15;\n                break;\n              }\n              _context8.next = 10;\n              return this.processAndValidateRefreshHandler();\n            case 10:\n              refreshedAccessToken = _context8.sent;\n              if (!(refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token)) {\n                _context8.next = 15;\n                break;\n              }\n              this.setCredentials(refreshedAccessToken);\n              _headers2 = {\n                Authorization: 'Bearer ' + this.credentials.access_token\n              };\n              return _context8.abrupt(\"return\", {\n                headers: this.addSharedMetadataHeaders(_headers2)\n              });\n            case 15:\n              if (!this.apiKey) {\n                _context8.next = 17;\n                break;\n              }\n              return _context8.abrupt(\"return\", {\n                headers: {\n                  'X-Goog-Api-Key': this.apiKey\n                }\n              });\n            case 17:\n              r = null;\n              tokens = null;\n              _context8.prev = 19;\n              _context8.next = 22;\n              return this.refreshToken(thisCreds.refresh_token);\n            case 22:\n              r = _context8.sent;\n              tokens = r.tokens;\n              _context8.next = 31;\n              break;\n            case 26:\n              _context8.prev = 26;\n              _context8.t0 = _context8[\"catch\"](19);\n              e = _context8.t0;\n              if (e.response && (e.response.status === 403 || e.response.status === 404)) {\n                e.message = \"Could not refresh access token: \".concat(e.message);\n              }\n              throw e;\n            case 31:\n              credentials = this.credentials;\n              credentials.token_type = credentials.token_type || 'Bearer';\n              tokens.refresh_token = credentials.refresh_token;\n              this.credentials = tokens;\n              headers = {\n                Authorization: credentials.token_type + ' ' + tokens.access_token\n              };\n              return _context8.abrupt(\"return\", {\n                headers: this.addSharedMetadataHeaders(headers),\n                res: r.res\n              });\n            case 37:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this, [[19, 26]]);\n      }));\n      function getRequestMetadataAsync(_x5) {\n        return _getRequestMetadataAsync.apply(this, arguments);\n      }\n      return getRequestMetadataAsync;\n    }()\n    /**\n     * Generates an URL to revoke the given token.\n     * @param token The existing token to be revoked.\n     */\n  }, {\n    key: \"revokeToken\",\n    value: function revokeToken(token, callback) {\n      var opts = {\n        url: OAuth2Client.getRevokeTokenUrl(token),\n        method: 'POST'\n      };\n      if (callback) {\n        this.transporter.request(opts).then(function (r) {\n          return callback(null, r);\n        }, callback);\n      } else {\n        return this.transporter.request(opts);\n      }\n    }\n  }, {\n    key: \"revokeCredentials\",\n    value: function revokeCredentials(callback) {\n      if (callback) {\n        this.revokeCredentialsAsync().then(function (res) {\n          return callback(null, res);\n        }, callback);\n      } else {\n        return this.revokeCredentialsAsync();\n      }\n    }\n  }, {\n    key: \"revokeCredentialsAsync\",\n    value: function () {\n      var _revokeCredentialsAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n        var token;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              token = this.credentials.access_token;\n              this.credentials = {};\n              if (!token) {\n                _context9.next = 6;\n                break;\n              }\n              return _context9.abrupt(\"return\", this.revokeToken(token));\n            case 6:\n              throw new Error('No access token to revoke.');\n            case 7:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9, this);\n      }));\n      function revokeCredentialsAsync() {\n        return _revokeCredentialsAsync.apply(this, arguments);\n      }\n      return revokeCredentialsAsync;\n    }()\n  }, {\n    key: \"request\",\n    value: function request(opts, callback) {\n      if (callback) {\n        this.requestAsync(opts).then(function (r) {\n          return callback(null, r);\n        }, function (e) {\n          return callback(e, e.response);\n        });\n      } else {\n        return this.requestAsync(opts);\n      }\n    }\n  }, {\n    key: \"requestAsync\",\n    value: function () {\n      var _requestAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(opts) {\n        var retry,\n          r2,\n          r,\n          res,\n          statusCode,\n          mayRequireRefresh,\n          mayRequireRefreshWithNoRefreshToken,\n          isReadableStream,\n          isAuthErr,\n          refreshedAccessToken,\n          _args10 = arguments;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              retry = _args10.length > 1 && _args10[1] !== undefined ? _args10[1] : false;\n              _context10.prev = 1;\n              _context10.next = 4;\n              return this.getRequestMetadataAsync(opts.url);\n            case 4:\n              r = _context10.sent;\n              opts.headers = opts.headers || {};\n              if (r.headers && r.headers['x-goog-user-project']) {\n                opts.headers['x-goog-user-project'] = r.headers['x-goog-user-project'];\n              }\n              if (r.headers && r.headers.Authorization) {\n                opts.headers.Authorization = r.headers.Authorization;\n              }\n              if (this.apiKey) {\n                opts.headers['X-Goog-Api-Key'] = this.apiKey;\n              }\n              _context10.next = 11;\n              return this.transporter.request(opts);\n            case 11:\n              r2 = _context10.sent;\n              _context10.next = 36;\n              break;\n            case 14:\n              _context10.prev = 14;\n              _context10.t0 = _context10[\"catch\"](1);\n              res = _context10.t0.response;\n              if (!res) {\n                _context10.next = 35;\n                break;\n              }\n              statusCode = res.status; // Retry the request for metadata if the following criteria are true:\n              // - We haven't already retried.  It only makes sense to retry once.\n              // - The response was a 401 or a 403\n              // - The request didn't send a readableStream\n              // - An access_token and refresh_token were available, but either no\n              //   expiry_date was available or the forceRefreshOnFailure flag is set.\n              //   The absent expiry_date case can happen when developers stash the\n              //   access_token and refresh_token for later use, but the access_token\n              //   fails on the first try because it's expired. Some developers may\n              //   choose to enable forceRefreshOnFailure to mitigate time-related\n              //   errors.\n              // Or the following criteria are true:\n              // - We haven't already retried.  It only makes sense to retry once.\n              // - The response was a 401 or a 403\n              // - The request didn't send a readableStream\n              // - No refresh_token was available\n              // - An access_token and a refreshHandler callback were available, but\n              //   either no expiry_date was available or the forceRefreshOnFailure\n              //   flag is set. The access_token fails on the first try because it's\n              //   expired. Some developers may choose to enable forceRefreshOnFailure\n              //   to mitigate time-related errors.\n              mayRequireRefresh = this.credentials && this.credentials.access_token && this.credentials.refresh_token && (!this.credentials.expiry_date || this.forceRefreshOnFailure);\n              mayRequireRefreshWithNoRefreshToken = this.credentials && this.credentials.access_token && !this.credentials.refresh_token && (!this.credentials.expiry_date || this.forceRefreshOnFailure) && this.refreshHandler;\n              isReadableStream = res.config.data instanceof stream.Readable;\n              isAuthErr = statusCode === 401 || statusCode === 403;\n              if (!(!retry && isAuthErr && !isReadableStream && mayRequireRefresh)) {\n                _context10.next = 29;\n                break;\n              }\n              _context10.next = 26;\n              return this.refreshAccessTokenAsync();\n            case 26:\n              return _context10.abrupt(\"return\", this.requestAsync(opts, true));\n            case 29:\n              if (!(!retry && isAuthErr && !isReadableStream && mayRequireRefreshWithNoRefreshToken)) {\n                _context10.next = 35;\n                break;\n              }\n              _context10.next = 32;\n              return this.processAndValidateRefreshHandler();\n            case 32:\n              refreshedAccessToken = _context10.sent;\n              if (refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token) {\n                this.setCredentials(refreshedAccessToken);\n              }\n              return _context10.abrupt(\"return\", this.requestAsync(opts, true));\n            case 35:\n              throw _context10.t0;\n            case 36:\n              return _context10.abrupt(\"return\", r2);\n            case 37:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee10, this, [[1, 14]]);\n      }));\n      function requestAsync(_x6) {\n        return _requestAsync.apply(this, arguments);\n      }\n      return requestAsync;\n    }()\n  }, {\n    key: \"verifyIdToken\",\n    value: function verifyIdToken(options, callback) {\n      // This function used to accept two arguments instead of an options object.\n      // Check the types to help users upgrade with less pain.\n      // This check can be removed after a 2.0 release.\n      if (callback && typeof callback !== 'function') {\n        throw new Error('This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.');\n      }\n      if (callback) {\n        this.verifyIdTokenAsync(options).then(function (r) {\n          return callback(null, r);\n        }, callback);\n      } else {\n        return this.verifyIdTokenAsync(options);\n      }\n    }\n  }, {\n    key: \"verifyIdTokenAsync\",\n    value: function () {\n      var _verifyIdTokenAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(options) {\n        var response, login;\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              if (options.idToken) {\n                _context11.next = 2;\n                break;\n              }\n              throw new Error('The verifyIdToken method requires an ID Token');\n            case 2:\n              _context11.next = 4;\n              return this.getFederatedSignonCertsAsync();\n            case 4:\n              response = _context11.sent;\n              _context11.next = 7;\n              return this.verifySignedJwtWithCertsAsync(options.idToken, response.certs, options.audience, OAuth2Client.ISSUERS_, options.maxExpiry);\n            case 7:\n              login = _context11.sent;\n              return _context11.abrupt(\"return\", login);\n            case 9:\n            case \"end\":\n              return _context11.stop();\n          }\n        }, _callee11, this);\n      }));\n      function verifyIdTokenAsync(_x7) {\n        return _verifyIdTokenAsync.apply(this, arguments);\n      }\n      return verifyIdTokenAsync;\n    }()\n    /**\n     * Obtains information about the provisioned access token.  Especially useful\n     * if you want to check the scopes that were provisioned to a given token.\n     *\n     * @param accessToken Required.  The Access Token for which you want to get\n     * user info.\n     */\n  }, {\n    key: \"getTokenInfo\",\n    value: function () {\n      var _getTokenInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(accessToken) {\n        var _yield$this$transport, data, info;\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) switch (_context12.prev = _context12.next) {\n            case 0:\n              _context12.next = 2;\n              return this.transporter.request({\n                method: 'POST',\n                headers: {\n                  'Content-Type': 'application/x-www-form-urlencoded',\n                  Authorization: \"Bearer \".concat(accessToken)\n                },\n                url: OAuth2Client.GOOGLE_TOKEN_INFO_URL\n              });\n            case 2:\n              _yield$this$transport = _context12.sent;\n              data = _yield$this$transport.data;\n              info = Object.assign({\n                expiry_date: new Date().getTime() + data.expires_in * 1000,\n                scopes: data.scope.split(' ')\n              }, data);\n              delete info.expires_in;\n              delete info.scope;\n              return _context12.abrupt(\"return\", info);\n            case 8:\n            case \"end\":\n              return _context12.stop();\n          }\n        }, _callee12, this);\n      }));\n      function getTokenInfo(_x8) {\n        return _getTokenInfo.apply(this, arguments);\n      }\n      return getTokenInfo;\n    }()\n  }, {\n    key: \"getFederatedSignonCerts\",\n    value: function getFederatedSignonCerts(callback) {\n      if (callback) {\n        this.getFederatedSignonCertsAsync().then(function (r) {\n          return callback(null, r.certs, r.res);\n        }, callback);\n      } else {\n        return this.getFederatedSignonCertsAsync();\n      }\n    }\n  }, {\n    key: \"getFederatedSignonCertsAsync\",\n    value: function () {\n      var _getFederatedSignonCertsAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13() {\n        var nowTime, format, res, url, cacheControl, cacheAge, pattern, regexResult, certificates, _iterator, _step, key, now;\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) switch (_context13.prev = _context13.next) {\n            case 0:\n              nowTime = new Date().getTime();\n              format = (0, crypto_1.hasBrowserCrypto)() ? CertificateFormat.JWK : CertificateFormat.PEM;\n              if (!(this.certificateExpiry && nowTime < this.certificateExpiry.getTime() && this.certificateCacheFormat === format)) {\n                _context13.next = 4;\n                break;\n              }\n              return _context13.abrupt(\"return\", {\n                certs: this.certificateCache,\n                format: format\n              });\n            case 4:\n              _context13.t0 = format;\n              _context13.next = _context13.t0 === CertificateFormat.PEM ? 7 : _context13.t0 === CertificateFormat.JWK ? 9 : 11;\n              break;\n            case 7:\n              url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_;\n              return _context13.abrupt(\"break\", 12);\n            case 9:\n              url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_;\n              return _context13.abrupt(\"break\", 12);\n            case 11:\n              throw new Error(\"Unsupported certificate format \".concat(format));\n            case 12:\n              _context13.prev = 12;\n              _context13.next = 15;\n              return this.transporter.request({\n                url: url\n              });\n            case 15:\n              res = _context13.sent;\n              _context13.next = 22;\n              break;\n            case 18:\n              _context13.prev = 18;\n              _context13.t1 = _context13[\"catch\"](12);\n              if (_context13.t1 instanceof Error) {\n                _context13.t1.message = \"Failed to retrieve verification certificates: \".concat(_context13.t1.message);\n              }\n              throw _context13.t1;\n            case 22:\n              cacheControl = res ? res.headers['cache-control'] : undefined;\n              cacheAge = -1;\n              if (cacheControl) {\n                pattern = new RegExp('max-age=([0-9]*)');\n                regexResult = pattern.exec(cacheControl);\n                if (regexResult && regexResult.length === 2) {\n                  // Cache results with max-age (in seconds)\n                  cacheAge = Number(regexResult[1]) * 1000; // milliseconds\n                }\n              }\n              certificates = {};\n              _context13.t2 = format;\n              _context13.next = _context13.t2 === CertificateFormat.PEM ? 29 : _context13.t2 === CertificateFormat.JWK ? 31 : 34;\n              break;\n            case 29:\n              certificates = res.data;\n              return _context13.abrupt(\"break\", 35);\n            case 31:\n              _iterator = _createForOfIteratorHelper(res.data.keys);\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  key = _step.value;\n                  certificates[key.kid] = key;\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n              return _context13.abrupt(\"break\", 35);\n            case 34:\n              throw new Error(\"Unsupported certificate format \".concat(format));\n            case 35:\n              now = new Date();\n              this.certificateExpiry = cacheAge === -1 ? null : new Date(now.getTime() + cacheAge);\n              this.certificateCache = certificates;\n              this.certificateCacheFormat = format;\n              return _context13.abrupt(\"return\", {\n                certs: certificates,\n                format: format,\n                res: res\n              });\n            case 40:\n            case \"end\":\n              return _context13.stop();\n          }\n        }, _callee13, this, [[12, 18]]);\n      }));\n      function getFederatedSignonCertsAsync() {\n        return _getFederatedSignonCertsAsync.apply(this, arguments);\n      }\n      return getFederatedSignonCertsAsync;\n    }()\n  }, {\n    key: \"getIapPublicKeys\",\n    value: function getIapPublicKeys(callback) {\n      if (callback) {\n        this.getIapPublicKeysAsync().then(function (r) {\n          return callback(null, r.pubkeys, r.res);\n        }, callback);\n      } else {\n        return this.getIapPublicKeysAsync();\n      }\n    }\n  }, {\n    key: \"getIapPublicKeysAsync\",\n    value: function () {\n      var _getIapPublicKeysAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14() {\n        var res, url;\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) switch (_context14.prev = _context14.next) {\n            case 0:\n              url = OAuth2Client.GOOGLE_OAUTH2_IAP_PUBLIC_KEY_URL_;\n              _context14.prev = 1;\n              _context14.next = 4;\n              return this.transporter.request({\n                url: url\n              });\n            case 4:\n              res = _context14.sent;\n              _context14.next = 11;\n              break;\n            case 7:\n              _context14.prev = 7;\n              _context14.t0 = _context14[\"catch\"](1);\n              if (_context14.t0 instanceof Error) {\n                _context14.t0.message = \"Failed to retrieve verification certificates: \".concat(_context14.t0.message);\n              }\n              throw _context14.t0;\n            case 11:\n              return _context14.abrupt(\"return\", {\n                pubkeys: res.data,\n                res: res\n              });\n            case 12:\n            case \"end\":\n              return _context14.stop();\n          }\n        }, _callee14, this, [[1, 7]]);\n      }));\n      function getIapPublicKeysAsync() {\n        return _getIapPublicKeysAsync.apply(this, arguments);\n      }\n      return getIapPublicKeysAsync;\n    }()\n  }, {\n    key: \"verifySignedJwtWithCerts\",\n    value: function verifySignedJwtWithCerts() {\n      // To make the code compatible with browser SubtleCrypto we need to make\n      // this method async.\n      throw new Error('verifySignedJwtWithCerts is removed, please use verifySignedJwtWithCertsAsync instead.');\n    }\n    /**\n     * Verify the id token is signed with the correct certificate\n     * and is from the correct audience.\n     * @param jwt The jwt to verify (The ID Token in this case).\n     * @param certs The array of certs to test the jwt against.\n     * @param requiredAudience The audience to test the jwt against.\n     * @param issuers The allowed issuers of the jwt (Optional).\n     * @param maxExpiry The max expiry the certificate can be (Optional).\n     * @return Returns a promise resolving to LoginTicket on verification.\n     */\n  }, {\n    key: \"verifySignedJwtWithCertsAsync\",\n    value: function () {\n      var _verifySignedJwtWithCertsAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15(jwt, certs, requiredAudience, issuers, maxExpiry) {\n        var crypto, segments, signed, signature, envelope, payload, cert, verified, iat, exp, now, earliest, latest, aud, audVerified;\n        return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) switch (_context15.prev = _context15.next) {\n            case 0:\n              crypto = (0, crypto_1.createCrypto)();\n              if (!maxExpiry) {\n                maxExpiry = OAuth2Client.MAX_TOKEN_LIFETIME_SECS_;\n              }\n              segments = jwt.split('.');\n              if (!(segments.length !== 3)) {\n                _context15.next = 5;\n                break;\n              }\n              throw new Error('Wrong number of segments in token: ' + jwt);\n            case 5:\n              signed = segments[0] + '.' + segments[1];\n              signature = segments[2];\n              _context15.prev = 7;\n              envelope = JSON.parse(crypto.decodeBase64StringUtf8(segments[0]));\n              _context15.next = 15;\n              break;\n            case 11:\n              _context15.prev = 11;\n              _context15.t0 = _context15[\"catch\"](7);\n              if (_context15.t0 instanceof Error) {\n                _context15.t0.message = \"Can't parse token envelope: \".concat(segments[0], \"': \").concat(_context15.t0.message);\n              }\n              throw _context15.t0;\n            case 15:\n              if (envelope) {\n                _context15.next = 17;\n                break;\n              }\n              throw new Error(\"Can't parse token envelope: \" + segments[0]);\n            case 17:\n              _context15.prev = 17;\n              payload = JSON.parse(crypto.decodeBase64StringUtf8(segments[1]));\n              _context15.next = 25;\n              break;\n            case 21:\n              _context15.prev = 21;\n              _context15.t1 = _context15[\"catch\"](17);\n              if (_context15.t1 instanceof Error) {\n                _context15.t1.message = \"Can't parse token payload '\".concat(segments[0]);\n              }\n              throw _context15.t1;\n            case 25:\n              if (payload) {\n                _context15.next = 27;\n                break;\n              }\n              throw new Error(\"Can't parse token payload: \" + segments[1]);\n            case 27:\n              if (Object.prototype.hasOwnProperty.call(certs, envelope.kid)) {\n                _context15.next = 29;\n                break;\n              }\n              throw new Error('No pem found for envelope: ' + JSON.stringify(envelope));\n            case 29:\n              cert = certs[envelope.kid];\n              if (envelope.alg === 'ES256') {\n                signature = formatEcdsa.joseToDer(signature, 'ES256').toString('base64');\n              }\n              _context15.next = 33;\n              return crypto.verify(cert, signed, signature);\n            case 33:\n              verified = _context15.sent;\n              if (verified) {\n                _context15.next = 36;\n                break;\n              }\n              throw new Error('Invalid token signature: ' + jwt);\n            case 36:\n              if (payload.iat) {\n                _context15.next = 38;\n                break;\n              }\n              throw new Error('No issue time in token: ' + JSON.stringify(payload));\n            case 38:\n              if (payload.exp) {\n                _context15.next = 40;\n                break;\n              }\n              throw new Error('No expiration time in token: ' + JSON.stringify(payload));\n            case 40:\n              iat = Number(payload.iat);\n              if (!isNaN(iat)) {\n                _context15.next = 43;\n                break;\n              }\n              throw new Error('iat field using invalid format');\n            case 43:\n              exp = Number(payload.exp);\n              if (!isNaN(exp)) {\n                _context15.next = 46;\n                break;\n              }\n              throw new Error('exp field using invalid format');\n            case 46:\n              now = new Date().getTime() / 1000;\n              if (!(exp >= now + maxExpiry)) {\n                _context15.next = 49;\n                break;\n              }\n              throw new Error('Expiration time too far in future: ' + JSON.stringify(payload));\n            case 49:\n              earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n              latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n              if (!(now < earliest)) {\n                _context15.next = 53;\n                break;\n              }\n              throw new Error('Token used too early, ' + now + ' < ' + earliest + ': ' + JSON.stringify(payload));\n            case 53:\n              if (!(now > latest)) {\n                _context15.next = 55;\n                break;\n              }\n              throw new Error('Token used too late, ' + now + ' > ' + latest + ': ' + JSON.stringify(payload));\n            case 55:\n              if (!(issuers && issuers.indexOf(payload.iss) < 0)) {\n                _context15.next = 57;\n                break;\n              }\n              throw new Error('Invalid issuer, expected one of [' + issuers + '], but got ' + payload.iss);\n            case 57:\n              if (!(typeof requiredAudience !== 'undefined' && requiredAudience !== null)) {\n                _context15.next = 63;\n                break;\n              }\n              aud = payload.aud;\n              audVerified = false; // If the requiredAudience is an array, check if it contains token\n              // audience\n              if (requiredAudience.constructor === Array) {\n                audVerified = requiredAudience.indexOf(aud) > -1;\n              } else {\n                audVerified = aud === requiredAudience;\n              }\n              if (audVerified) {\n                _context15.next = 63;\n                break;\n              }\n              throw new Error('Wrong recipient, payload audience != requiredAudience');\n            case 63:\n              return _context15.abrupt(\"return\", new loginticket_1.LoginTicket(envelope, payload));\n            case 64:\n            case \"end\":\n              return _context15.stop();\n          }\n        }, _callee15, null, [[7, 11], [17, 21]]);\n      }));\n      function verifySignedJwtWithCertsAsync(_x9, _x10, _x11, _x12, _x13) {\n        return _verifySignedJwtWithCertsAsync.apply(this, arguments);\n      }\n      return verifySignedJwtWithCertsAsync;\n    }()\n    /**\n     * Returns a promise that resolves with AccessTokenResponse type if\n     * refreshHandler is defined.\n     * If not, nothing is returned.\n     */\n  }, {\n    key: \"processAndValidateRefreshHandler\",\n    value: function () {\n      var _processAndValidateRefreshHandler = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee16() {\n        var accessTokenResponse;\n        return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) switch (_context16.prev = _context16.next) {\n            case 0:\n              if (!this.refreshHandler) {\n                _context16.next = 7;\n                break;\n              }\n              _context16.next = 3;\n              return this.refreshHandler();\n            case 3:\n              accessTokenResponse = _context16.sent;\n              if (accessTokenResponse.access_token) {\n                _context16.next = 6;\n                break;\n              }\n              throw new Error('No access token is returned by the refreshHandler callback.');\n            case 6:\n              return _context16.abrupt(\"return\", accessTokenResponse);\n            case 7:\n              return _context16.abrupt(\"return\");\n            case 8:\n            case \"end\":\n              return _context16.stop();\n          }\n        }, _callee16, this);\n      }));\n      function processAndValidateRefreshHandler() {\n        return _processAndValidateRefreshHandler.apply(this, arguments);\n      }\n      return processAndValidateRefreshHandler;\n    }()\n    /**\n     * Returns true if a token is expired or will expire within\n     * eagerRefreshThresholdMillismilliseconds.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     */\n  }, {\n    key: \"isTokenExpiring\",\n    value: function isTokenExpiring() {\n      var expiryDate = this.credentials.expiry_date;\n      return expiryDate ? expiryDate <= new Date().getTime() + this.eagerRefreshThresholdMillis : false;\n    }\n  }], [{\n    key: \"getRevokeTokenUrl\",\n    value: function getRevokeTokenUrl(token) {\n      var parameters = querystring.stringify({\n        token: token\n      });\n      return \"\".concat(OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_, \"?\").concat(parameters);\n    }\n  }]);\n  return OAuth2Client;\n}(authclient_1.AuthClient);\nexports.OAuth2Client = OAuth2Client;\nOAuth2Client.GOOGLE_TOKEN_INFO_URL = 'https://oauth2.googleapis.com/tokeninfo';\n/**\n * The base URL for auth endpoints.\n */\nOAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_ = 'https://accounts.google.com/o/oauth2/v2/auth';\n/**\n * The base endpoint for token retrieval.\n */\nOAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_ = 'https://oauth2.googleapis.com/token';\n/**\n * The base endpoint to revoke tokens.\n */\nOAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ = 'https://oauth2.googleapis.com/revoke';\n/**\n * Google Sign on certificates in PEM format.\n */\nOAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v1/certs';\n/**\n * Google Sign on certificates in JWK format.\n */\nOAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v3/certs';\n/**\n * Google Sign on certificates in JWK format.\n */\nOAuth2Client.GOOGLE_OAUTH2_IAP_PUBLIC_KEY_URL_ = 'https://www.gstatic.com/iap/verify/public_key';\n/**\n * Clock skew - five minutes in seconds\n */\nOAuth2Client.CLOCK_SKEW_SECS_ = 300;\n/**\n * Max Token Lifetime is one day in seconds\n */\nOAuth2Client.MAX_TOKEN_LIFETIME_SECS_ = 86400;\n/**\n * The allowed oauth token issuers.\n */\nOAuth2Client.ISSUERS_ = ['accounts.google.com', 'https://accounts.google.com'];","map":null,"metadata":{},"sourceType":"script"}