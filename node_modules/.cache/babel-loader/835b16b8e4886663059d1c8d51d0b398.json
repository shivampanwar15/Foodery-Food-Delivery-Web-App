{"ast":null,"code":"\"use strict\";\n\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar _regeneratorRuntime = require(\"/Users/shivampanwar/Desktop/GoFood/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\nvar _asyncToGenerator = require(\"/Users/shivampanwar/Desktop/GoFood/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\nvar _classCallCheck = require(\"/Users/shivampanwar/Desktop/GoFood/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/Users/shivampanwar/Desktop/GoFood/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"/Users/shivampanwar/Desktop/GoFood/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\nvar _get = require(\"/Users/shivampanwar/Desktop/GoFood/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\nvar _getPrototypeOf = require(\"/Users/shivampanwar/Desktop/GoFood/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"/Users/shivampanwar/Desktop/GoFood/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DownscopedClient = exports.EXPIRATION_TIME_OFFSET = exports.MAX_ACCESS_BOUNDARY_RULES_COUNT = void 0;\nvar stream = require(\"stream\");\nvar authclient_1 = require(\"./authclient\");\nvar sts = require(\"./stscredentials\");\n/**\n * The required token exchange grant_type: rfc8693#section-2.1\n */\nvar STS_GRANT_TYPE = 'urn:ietf:params:oauth:grant-type:token-exchange';\n/**\n * The requested token exchange requested_token_type: rfc8693#section-2.1\n */\nvar STS_REQUEST_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';\n/**\n * The requested token exchange subject_token_type: rfc8693#section-2.1\n */\nvar STS_SUBJECT_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';\n/** The STS access token exchange end point. */\nvar STS_ACCESS_TOKEN_URL = 'https://sts.googleapis.com/v1/token';\n/**\n * The maximum number of access boundary rules a Credential Access Boundary\n * can contain.\n */\nexports.MAX_ACCESS_BOUNDARY_RULES_COUNT = 10;\n/**\n * Offset to take into account network delays and server clock skews.\n */\nexports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1000;\n/**\n * Defines a set of Google credentials that are downscoped from an existing set\n * of Google OAuth2 credentials. This is useful to restrict the Identity and\n * Access Management (IAM) permissions that a short-lived credential can use.\n * The common pattern of usage is to have a token broker with elevated access\n * generate these downscoped credentials from higher access source credentials\n * and pass the downscoped short-lived access tokens to a token consumer via\n * some secure authenticated channel for limited access to Google Cloud Storage\n * resources.\n */\nvar DownscopedClient = /*#__PURE__*/function (_authclient_1$AuthCli) {\n  _inherits(DownscopedClient, _authclient_1$AuthCli);\n  /**\n   * Instantiates a downscoped client object using the provided source\n   * AuthClient and credential access boundary rules.\n   * To downscope permissions of a source AuthClient, a Credential Access\n   * Boundary that specifies which resources the new credential can access, as\n   * well as an upper bound on the permissions that are available on each\n   * resource, has to be defined. A downscoped client can then be instantiated\n   * using the source AuthClient and the Credential Access Boundary.\n   * @param authClient The source AuthClient to be downscoped based on the\n   *   provided Credential Access Boundary rules.\n   * @param credentialAccessBoundary The Credential Access Boundary which\n   *   contains a list of access boundary rules. Each rule contains information\n   *   on the resource that the rule applies to, the upper bound of the\n   *   permissions that are available on that resource and an optional\n   *   condition to further restrict permissions.\n   * @param additionalOptions Optional additional behavior customization\n   *   options. These currently customize expiration threshold time and\n   *   whether to retry on 401/403 API request errors.\n   * @param quotaProjectId Optional quota project id for setting up in the\n   *   x-goog-user-project header.\n   */\n  function DownscopedClient(authClient, credentialAccessBoundary, additionalOptions, quotaProjectId) {\n    var _this;\n    _classCallCheck(this, DownscopedClient);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(DownscopedClient).call(this));\n    _this.authClient = authClient;\n    _this.credentialAccessBoundary = credentialAccessBoundary;\n    // Check 1-10 Access Boundary Rules are defined within Credential Access\n    // Boundary.\n    if (credentialAccessBoundary.accessBoundary.accessBoundaryRules.length === 0) {\n      throw new Error('At least one access boundary rule needs to be defined.');\n    } else if (credentialAccessBoundary.accessBoundary.accessBoundaryRules.length > exports.MAX_ACCESS_BOUNDARY_RULES_COUNT) {\n      throw new Error('The provided access boundary has more than ' + \"\".concat(exports.MAX_ACCESS_BOUNDARY_RULES_COUNT, \" access boundary rules.\"));\n    }\n    // Check at least one permission should be defined in each Access Boundary\n    // Rule.\n    var _iterator = _createForOfIteratorHelper(credentialAccessBoundary.accessBoundary.accessBoundaryRules),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var rule = _step.value;\n        if (rule.availablePermissions.length === 0) {\n          throw new Error('At least one permission should be defined in access boundary rules.');\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    _this.stsCredential = new sts.StsCredentials(STS_ACCESS_TOKEN_URL);\n    _this.cachedDownscopedAccessToken = null;\n    // As threshold could be zero,\n    // eagerRefreshThresholdMillis || EXPIRATION_TIME_OFFSET will override the\n    // zero value.\n    if (typeof (additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.eagerRefreshThresholdMillis) !== 'number') {\n      _this.eagerRefreshThresholdMillis = exports.EXPIRATION_TIME_OFFSET;\n    } else {\n      _this.eagerRefreshThresholdMillis = additionalOptions.eagerRefreshThresholdMillis;\n    }\n    _this.forceRefreshOnFailure = !!(additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.forceRefreshOnFailure);\n    _this.quotaProjectId = quotaProjectId;\n    return _this;\n  }\n  /**\n   * Provides a mechanism to inject Downscoped access tokens directly.\n   * The expiry_date field is required to facilitate determination of the token\n   * expiration which would make it easier for the token consumer to handle.\n   * @param credentials The Credentials object to set on the current client.\n   */\n  _createClass(DownscopedClient, [{\n    key: \"setCredentials\",\n    value: function setCredentials(credentials) {\n      if (!credentials.expiry_date) {\n        throw new Error('The access token expiry_date field is missing in the provided ' + 'credentials.');\n      }\n      _get(_getPrototypeOf(DownscopedClient.prototype), \"setCredentials\", this).call(this, credentials);\n      this.cachedDownscopedAccessToken = credentials;\n    }\n  }, {\n    key: \"getAccessToken\",\n    value: function () {\n      var _getAccessToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!(!this.cachedDownscopedAccessToken || this.isExpired(this.cachedDownscopedAccessToken))) {\n                _context.next = 3;\n                break;\n              }\n              _context.next = 3;\n              return this.refreshAccessTokenAsync();\n            case 3:\n              return _context.abrupt(\"return\", {\n                token: this.cachedDownscopedAccessToken.access_token,\n                expirationTime: this.cachedDownscopedAccessToken.expiry_date,\n                res: this.cachedDownscopedAccessToken.res\n              });\n            case 4:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function getAccessToken() {\n        return _getAccessToken.apply(this, arguments);\n      }\n      return getAccessToken;\n    }()\n    /**\n     * The main authentication interface. It takes an optional url which when\n     * present is the endpoint being accessed, and returns a Promise which\n     * resolves with authorization header fields.\n     *\n     * The result has the form:\n     * { Authorization: 'Bearer <access_token_value>' }\n     */\n  }, {\n    key: \"getRequestHeaders\",\n    value: function () {\n      var _getRequestHeaders = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var accessTokenResponse, headers;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return this.getAccessToken();\n            case 2:\n              accessTokenResponse = _context2.sent;\n              headers = {\n                Authorization: \"Bearer \".concat(accessTokenResponse.token)\n              };\n              return _context2.abrupt(\"return\", this.addSharedMetadataHeaders(headers));\n            case 5:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function getRequestHeaders() {\n        return _getRequestHeaders.apply(this, arguments);\n      }\n      return getRequestHeaders;\n    }()\n  }, {\n    key: \"request\",\n    value: function request(opts, callback) {\n      if (callback) {\n        this.requestAsync(opts).then(function (r) {\n          return callback(null, r);\n        }, function (e) {\n          return callback(e, e.response);\n        });\n      } else {\n        return this.requestAsync(opts);\n      }\n    }\n    /**\n     * Authenticates the provided HTTP request, processes it and resolves with the\n     * returned response.\n     * @param opts The HTTP request options.\n     * @param retry Whether the current attempt is a retry after a failed attempt.\n     * @return A promise that resolves with the successful response.\n     */\n  }, {\n    key: \"requestAsync\",\n    value: function () {\n      var _requestAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(opts) {\n        var retry,\n          response,\n          requestHeaders,\n          res,\n          statusCode,\n          isReadableStream,\n          isAuthErr,\n          _args3 = arguments;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              retry = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : false;\n              _context3.prev = 1;\n              _context3.next = 4;\n              return this.getRequestHeaders();\n            case 4:\n              requestHeaders = _context3.sent;\n              opts.headers = opts.headers || {};\n              if (requestHeaders && requestHeaders['x-goog-user-project']) {\n                opts.headers['x-goog-user-project'] = requestHeaders['x-goog-user-project'];\n              }\n              if (requestHeaders && requestHeaders.Authorization) {\n                opts.headers.Authorization = requestHeaders.Authorization;\n              }\n              _context3.next = 10;\n              return this.transporter.request(opts);\n            case 10:\n              response = _context3.sent;\n              _context3.next = 27;\n              break;\n            case 13:\n              _context3.prev = 13;\n              _context3.t0 = _context3[\"catch\"](1);\n              res = _context3.t0.response;\n              if (!res) {\n                _context3.next = 26;\n                break;\n              }\n              statusCode = res.status; // Retry the request for metadata if the following criteria are true:\n              // - We haven't already retried.  It only makes sense to retry once.\n              // - The response was a 401 or a 403\n              // - The request didn't send a readableStream\n              // - forceRefreshOnFailure is true\n              isReadableStream = res.config.data instanceof stream.Readable;\n              isAuthErr = statusCode === 401 || statusCode === 403;\n              if (!(!retry && isAuthErr && !isReadableStream && this.forceRefreshOnFailure)) {\n                _context3.next = 26;\n                break;\n              }\n              _context3.next = 23;\n              return this.refreshAccessTokenAsync();\n            case 23:\n              _context3.next = 25;\n              return this.requestAsync(opts, true);\n            case 25:\n              return _context3.abrupt(\"return\", _context3.sent);\n            case 26:\n              throw _context3.t0;\n            case 27:\n              return _context3.abrupt(\"return\", response);\n            case 28:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this, [[1, 13]]);\n      }));\n      function requestAsync(_x) {\n        return _requestAsync.apply(this, arguments);\n      }\n      return requestAsync;\n    }()\n    /**\n     * Forces token refresh, even if unexpired tokens are currently cached.\n     * GCP access tokens are retrieved from authclient object/source credential.\n     * Then GCP access tokens are exchanged for downscoped access tokens via the\n     * token exchange endpoint.\n     * @return A promise that resolves with the fresh downscoped access token.\n     */\n  }, {\n    key: \"refreshAccessTokenAsync\",\n    value: function () {\n      var _refreshAccessTokenAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var _a, subjectToken, stsCredentialsOptions, stsResponse, sourceCredExpireDate, expiryDate;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.next = 2;\n              return this.authClient.getAccessToken();\n            case 2:\n              subjectToken = _context4.sent.token;\n              // Construct the STS credentials options.\n              stsCredentialsOptions = {\n                grantType: STS_GRANT_TYPE,\n                requestedTokenType: STS_REQUEST_TOKEN_TYPE,\n                subjectToken: subjectToken,\n                subjectTokenType: STS_SUBJECT_TOKEN_TYPE\n              }; // Exchange the source AuthClient access token for a Downscoped access\n              // token.\n              _context4.next = 6;\n              return this.stsCredential.exchangeToken(stsCredentialsOptions, undefined, this.credentialAccessBoundary);\n            case 6:\n              stsResponse = _context4.sent;\n              /**\n               * The STS endpoint will only return the expiration time for the downscoped\n               * access token if the original access token represents a service account.\n               * The downscoped token's expiration time will always match the source\n               * credential expiration. When no expires_in is returned, we can copy the\n               * source credential's expiration time.\n               */\n              sourceCredExpireDate = ((_a = this.authClient.credentials) === null || _a === void 0 ? void 0 : _a.expiry_date) || null;\n              expiryDate = stsResponse.expires_in ? new Date().getTime() + stsResponse.expires_in * 1000 : sourceCredExpireDate; // Save response in cached access token.\n              this.cachedDownscopedAccessToken = {\n                access_token: stsResponse.access_token,\n                expiry_date: expiryDate,\n                res: stsResponse.res\n              };\n              // Save credentials.\n              this.credentials = {};\n              Object.assign(this.credentials, this.cachedDownscopedAccessToken);\n              delete this.credentials.res;\n              // Trigger tokens event to notify external listeners.\n              this.emit('tokens', {\n                refresh_token: null,\n                expiry_date: this.cachedDownscopedAccessToken.expiry_date,\n                access_token: this.cachedDownscopedAccessToken.access_token,\n                token_type: 'Bearer',\n                id_token: null\n              });\n              // Return the cached access token.\n              return _context4.abrupt(\"return\", this.cachedDownscopedAccessToken);\n            case 15:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function refreshAccessTokenAsync() {\n        return _refreshAccessTokenAsync.apply(this, arguments);\n      }\n      return refreshAccessTokenAsync;\n    }()\n    /**\n     * Returns whether the provided credentials are expired or not.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     * @param downscopedAccessToken The credentials to check for expiration.\n     * @return Whether the credentials are expired or not.\n     */\n  }, {\n    key: \"isExpired\",\n    value: function isExpired(downscopedAccessToken) {\n      var now = new Date().getTime();\n      return downscopedAccessToken.expiry_date ? now >= downscopedAccessToken.expiry_date - this.eagerRefreshThresholdMillis : false;\n    }\n  }]);\n  return DownscopedClient;\n}(authclient_1.AuthClient);\nexports.DownscopedClient = DownscopedClient;","map":null,"metadata":{},"sourceType":"script"}