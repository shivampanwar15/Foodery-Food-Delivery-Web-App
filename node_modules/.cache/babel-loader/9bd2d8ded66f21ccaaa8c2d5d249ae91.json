{"ast":null,"code":"var fs = require('fs');\nvar path = require('path');\nvar os = require('os');\nvar crypto = require('crypto');\nvar packageJson = require('../package.json');\nvar version = packageJson.version;\nvar LINE = /(?:^|^)\\s*(?:export\\s+)?([\\w.-]+)(?:\\s*=\\s*?|:\\s+?)(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?\\s*(?:#.*)?(?:$|$)/mg;\n\n// Parse src into an Object\nfunction parse(src) {\n  var obj = {};\n\n  // Convert buffer to string\n  var lines = src.toString();\n\n  // Convert line breaks to same format\n  lines = lines.replace(/\\r\\n?/mg, '\\n');\n  var match;\n  while ((match = LINE.exec(lines)) != null) {\n    var key = match[1];\n\n    // Default undefined or null to empty string\n    var value = match[2] || '';\n\n    // Remove whitespace\n    value = value.trim();\n\n    // Check if double quoted\n    var maybeQuote = value[0];\n\n    // Remove surrounding quotes\n    value = value.replace(/^(['\"`])([\\s\\S]*)\\1$/mg, '$2');\n\n    // Expand newlines if double quoted\n    if (maybeQuote === '\"') {\n      value = value.replace(/\\\\n/g, '\\n');\n      value = value.replace(/\\\\r/g, '\\r');\n    }\n\n    // Add to object\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _parseVault(options) {\n  var vaultPath = _vaultPath(options);\n\n  // Parse .env.vault\n  var result = DotenvModule.configDotenv({\n    path: vaultPath\n  });\n  if (!result.parsed) {\n    throw new Error(\"MISSING_DATA: Cannot parse \".concat(vaultPath, \" for an unknown reason\"));\n  }\n\n  // handle scenario for comma separated keys - for use with key rotation\n  // example: DOTENV_KEY=\"dotenv://:key_1234@dotenv.org/vault/.env.vault?environment=prod,dotenv://:key_7890@dotenv.org/vault/.env.vault?environment=prod\"\n  var keys = _dotenvKey(options).split(',');\n  var length = keys.length;\n  var decrypted;\n  for (var i = 0; i < length; i++) {\n    try {\n      // Get full key\n      var key = keys[i].trim();\n\n      // Get instructions for decrypt\n      var attrs = _instructions(result, key);\n\n      // Decrypt\n      decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);\n      break;\n    } catch (error) {\n      // last key\n      if (i + 1 >= length) {\n        throw error;\n      }\n      // try next key\n    }\n  }\n\n  // Parse decrypted .env string\n  return DotenvModule.parse(decrypted);\n}\nfunction _log(message) {\n  console.log(\"[dotenv@\".concat(version, \"][INFO] \").concat(message));\n}\nfunction _warn(message) {\n  console.log(\"[dotenv@\".concat(version, \"][WARN] \").concat(message));\n}\nfunction _debug(message) {\n  console.log(\"[dotenv@\".concat(version, \"][DEBUG] \").concat(message));\n}\nfunction _dotenvKey(options) {\n  // prioritize developer directly setting options.DOTENV_KEY\n  if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {\n    return options.DOTENV_KEY;\n  }\n\n  // secondary infra already contains a DOTENV_KEY environment variable\n  if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {\n    return process.env.DOTENV_KEY;\n  }\n\n  // fallback to empty string\n  return '';\n}\nfunction _instructions(result, dotenvKey) {\n  // Parse DOTENV_KEY. Format is a URI\n  var uri;\n  try {\n    uri = new URL(dotenvKey);\n  } catch (error) {\n    if (error.code === 'ERR_INVALID_URL') {\n      throw new Error('INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenv.org/vault/.env.vault?environment=development');\n    }\n    throw error;\n  }\n\n  // Get decrypt key\n  var key = uri.password;\n  if (!key) {\n    throw new Error('INVALID_DOTENV_KEY: Missing key part');\n  }\n\n  // Get environment\n  var environment = uri.searchParams.get('environment');\n  if (!environment) {\n    throw new Error('INVALID_DOTENV_KEY: Missing environment part');\n  }\n\n  // Get ciphertext payload\n  var environmentKey = \"DOTENV_VAULT_\".concat(environment.toUpperCase());\n  var ciphertext = result.parsed[environmentKey]; // DOTENV_VAULT_PRODUCTION\n  if (!ciphertext) {\n    throw new Error(\"NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment \".concat(environmentKey, \" in your .env.vault file.\"));\n  }\n  return {\n    ciphertext: ciphertext,\n    key: key\n  };\n}\nfunction _vaultPath(options) {\n  var dotenvPath = path.resolve(process.cwd(), '.env');\n  if (options && options.path && options.path.length > 0) {\n    dotenvPath = options.path;\n  }\n\n  // Locate .env.vault\n  return dotenvPath.endsWith('.vault') ? dotenvPath : \"\".concat(dotenvPath, \".vault\");\n}\nfunction _resolveHome(envPath) {\n  return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath;\n}\nfunction _configVault(options) {\n  _log('Loading env from encrypted .env.vault');\n  var parsed = DotenvModule._parseVault(options);\n  var processEnv = process.env;\n  if (options && options.processEnv != null) {\n    processEnv = options.processEnv;\n  }\n  DotenvModule.populate(processEnv, parsed, options);\n  return {\n    parsed: parsed\n  };\n}\nfunction configDotenv(options) {\n  var dotenvPath = path.resolve(process.cwd(), '.env');\n  var encoding = 'utf8';\n  var debug = Boolean(options && options.debug);\n  if (options) {\n    if (options.path != null) {\n      dotenvPath = _resolveHome(options.path);\n    }\n    if (options.encoding != null) {\n      encoding = options.encoding;\n    }\n  }\n  try {\n    // Specifying an encoding returns a string instead of a buffer\n    var parsed = DotenvModule.parse(fs.readFileSync(dotenvPath, {\n      encoding: encoding\n    }));\n    var processEnv = process.env;\n    if (options && options.processEnv != null) {\n      processEnv = options.processEnv;\n    }\n    DotenvModule.populate(processEnv, parsed, options);\n    return {\n      parsed: parsed\n    };\n  } catch (e) {\n    if (debug) {\n      _debug(\"Failed to load \".concat(dotenvPath, \" \").concat(e.message));\n    }\n    return {\n      error: e\n    };\n  }\n}\n\n// Populates process.env from .env file\nfunction config(options) {\n  var vaultPath = _vaultPath(options);\n\n  // fallback to original dotenv if DOTENV_KEY is not set\n  if (_dotenvKey(options).length === 0) {\n    return DotenvModule.configDotenv(options);\n  }\n\n  // dotenvKey exists but .env.vault file does not exist\n  if (!fs.existsSync(vaultPath)) {\n    _warn(\"You set DOTENV_KEY but you are missing a .env.vault file at \".concat(vaultPath, \". Did you forget to build it?\"));\n    return DotenvModule.configDotenv(options);\n  }\n  return DotenvModule._configVault(options);\n}\nfunction decrypt(encrypted, keyStr) {\n  var key = Buffer.from(keyStr.slice(-64), 'hex');\n  var ciphertext = Buffer.from(encrypted, 'base64');\n  var nonce = ciphertext.slice(0, 12);\n  var authTag = ciphertext.slice(-16);\n  ciphertext = ciphertext.slice(12, -16);\n  try {\n    var aesgcm = crypto.createDecipheriv('aes-256-gcm', key, nonce);\n    aesgcm.setAuthTag(authTag);\n    return \"\".concat(aesgcm.update(ciphertext)).concat(aesgcm.final());\n  } catch (error) {\n    var isRange = error instanceof RangeError;\n    var invalidKeyLength = error.message === 'Invalid key length';\n    var decryptionFailed = error.message === 'Unsupported state or unable to authenticate data';\n    if (isRange || invalidKeyLength) {\n      var msg = 'INVALID_DOTENV_KEY: It must be 64 characters long (or more)';\n      throw new Error(msg);\n    } else if (decryptionFailed) {\n      var _msg = 'DECRYPTION_FAILED: Please check your DOTENV_KEY';\n      throw new Error(_msg);\n    } else {\n      console.error('Error: ', error.code);\n      console.error('Error: ', error.message);\n      throw error;\n    }\n  }\n}\n\n// Populate process.env with parsed values\nfunction populate(processEnv, parsed) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var debug = Boolean(options && options.debug);\n  var override = Boolean(options && options.override);\n  if (typeof parsed !== 'object') {\n    throw new Error('OBJECT_REQUIRED: Please check the processEnv argument being passed to populate');\n  }\n\n  // Set process.env\n  for (var _i = 0, _Object$keys = Object.keys(parsed); _i < _Object$keys.length; _i++) {\n    var key = _Object$keys[_i];\n    if (Object.prototype.hasOwnProperty.call(processEnv, key)) {\n      if (override === true) {\n        processEnv[key] = parsed[key];\n      }\n      if (debug) {\n        if (override === true) {\n          _debug(\"\\\"\".concat(key, \"\\\" is already defined and WAS overwritten\"));\n        } else {\n          _debug(\"\\\"\".concat(key, \"\\\" is already defined and was NOT overwritten\"));\n        }\n      }\n    } else {\n      processEnv[key] = parsed[key];\n    }\n  }\n}\nvar DotenvModule = {\n  configDotenv: configDotenv,\n  _configVault: _configVault,\n  _parseVault: _parseVault,\n  config: config,\n  decrypt: decrypt,\n  parse: parse,\n  populate: populate\n};\nmodule.exports.configDotenv = DotenvModule.configDotenv;\nmodule.exports._configVault = DotenvModule._configVault;\nmodule.exports._parseVault = DotenvModule._parseVault;\nmodule.exports.config = DotenvModule.config;\nmodule.exports.decrypt = DotenvModule.decrypt;\nmodule.exports.parse = DotenvModule.parse;\nmodule.exports.populate = DotenvModule.populate;\nmodule.exports = DotenvModule;","map":null,"metadata":{},"sourceType":"script"}