{"ast":null,"code":"\"use strict\";\n\n// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar _regeneratorRuntime = require(\"/Users/shivampanwar/Desktop/GoFood/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\nvar _asyncToGenerator = require(\"/Users/shivampanwar/Desktop/GoFood/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\nvar _objectSpread = require(\"/Users/shivampanwar/Desktop/GoFood/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread\");\nvar _classCallCheck = require(\"/Users/shivampanwar/Desktop/GoFood/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/Users/shivampanwar/Desktop/GoFood/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PluggableAuthHandler = void 0;\nvar pluggable_auth_client_1 = require(\"./pluggable-auth-client\");\nvar executable_response_1 = require(\"./executable-response\");\nvar childProcess = require(\"child_process\");\nvar fs = require(\"fs\");\n/**\n * A handler used to retrieve 3rd party token responses from user defined\n * executables and cached file output for the PluggableAuthClient class.\n */\nvar PluggableAuthHandler = /*#__PURE__*/function () {\n  /**\n   * Instantiates a PluggableAuthHandler instance using the provided\n   * PluggableAuthHandlerOptions object.\n   */\n  function PluggableAuthHandler(options) {\n    _classCallCheck(this, PluggableAuthHandler);\n    if (!options.command) {\n      throw new Error('No command provided.');\n    }\n    this.commandComponents = PluggableAuthHandler.parseCommand(options.command);\n    this.timeoutMillis = options.timeoutMillis;\n    if (!this.timeoutMillis) {\n      throw new Error('No timeoutMillis provided.');\n    }\n    this.outputFile = options.outputFile;\n  }\n  /**\n   * Calls user provided executable to get a 3rd party subject token and\n   * returns the response.\n   * @param envMap a Map of additional Environment Variables required for\n   *   the executable.\n   * @return A promise that resolves with the executable response.\n   */\n  _createClass(PluggableAuthHandler, [{\n    key: \"retrieveResponseFromExecutable\",\n    value: function retrieveResponseFromExecutable(envMap) {\n      var _this = this;\n      return new Promise(function (resolve, reject) {\n        // Spawn process to run executable using added environment variables.\n        var child = childProcess.spawn(_this.commandComponents[0], _this.commandComponents.slice(1), {\n          env: _objectSpread({}, process.env, Object.fromEntries(envMap))\n        });\n        var output = '';\n        // Append stdout to output as executable runs.\n        child.stdout.on('data', function (data) {\n          output += data;\n        });\n        // Append stderr as executable runs.\n        child.stderr.on('data', function (err) {\n          output += err;\n        });\n        // Set up a timeout to end the child process and throw an error.\n        var timeout = setTimeout(function () {\n          // Kill child process and remove listeners so 'close' event doesn't get\n          // read after child process is killed.\n          child.removeAllListeners();\n          child.kill();\n          return reject(new Error('The executable failed to finish within the timeout specified.'));\n        }, _this.timeoutMillis);\n        child.on('close', function (code) {\n          // Cancel timeout if executable closes before timeout is reached.\n          clearTimeout(timeout);\n          if (code === 0) {\n            // If the executable completed successfully, try to return the parsed response.\n            try {\n              var responseJson = JSON.parse(output);\n              var response = new executable_response_1.ExecutableResponse(responseJson);\n              return resolve(response);\n            } catch (error) {\n              if (error instanceof executable_response_1.ExecutableResponseError) {\n                return reject(error);\n              }\n              return reject(new executable_response_1.ExecutableResponseError(\"The executable returned an invalid response: \".concat(output)));\n            }\n          } else {\n            return reject(new pluggable_auth_client_1.ExecutableError(output, code.toString()));\n          }\n        });\n      });\n    }\n    /**\n     * Checks user provided output file for response from previous run of\n     * executable and return the response if it exists, is formatted correctly, and is not expired.\n     */\n  }, {\n    key: \"retrieveCachedResponse\",\n    value: function () {\n      var _retrieveCachedResponse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var filePath, responseString, responseJson, response;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!(!this.outputFile || this.outputFile.length === 0)) {\n                _context.next = 2;\n                break;\n              }\n              return _context.abrupt(\"return\", undefined);\n            case 2:\n              _context.prev = 2;\n              _context.next = 5;\n              return fs.promises.realpath(this.outputFile);\n            case 5:\n              filePath = _context.sent;\n              _context.next = 11;\n              break;\n            case 8:\n              _context.prev = 8;\n              _context.t0 = _context[\"catch\"](2);\n              return _context.abrupt(\"return\", undefined);\n            case 11:\n              _context.next = 13;\n              return fs.promises.lstat(filePath);\n            case 13:\n              if (_context.sent.isFile()) {\n                _context.next = 15;\n                break;\n              }\n              return _context.abrupt(\"return\", undefined);\n            case 15:\n              _context.next = 17;\n              return fs.promises.readFile(filePath, {\n                encoding: 'utf8'\n              });\n            case 17:\n              responseString = _context.sent;\n              if (!(responseString === '')) {\n                _context.next = 20;\n                break;\n              }\n              return _context.abrupt(\"return\", undefined);\n            case 20:\n              _context.prev = 20;\n              responseJson = JSON.parse(responseString);\n              response = new executable_response_1.ExecutableResponse(responseJson); // Check if response is successful and unexpired.\n              if (!response.isValid()) {\n                _context.next = 25;\n                break;\n              }\n              return _context.abrupt(\"return\", new executable_response_1.ExecutableResponse(responseJson));\n            case 25:\n              return _context.abrupt(\"return\", undefined);\n            case 28:\n              _context.prev = 28;\n              _context.t1 = _context[\"catch\"](20);\n              if (!(_context.t1 instanceof executable_response_1.ExecutableResponseError)) {\n                _context.next = 32;\n                break;\n              }\n              throw _context.t1;\n            case 32:\n              throw new executable_response_1.ExecutableResponseError(\"The output file contained an invalid response: \".concat(responseString));\n            case 33:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[2, 8], [20, 28]]);\n      }));\n      function retrieveCachedResponse() {\n        return _retrieveCachedResponse.apply(this, arguments);\n      }\n      return retrieveCachedResponse;\n    }()\n    /**\n     * Parses given command string into component array, splitting on spaces unless\n     * spaces are between quotation marks.\n     */\n  }], [{\n    key: \"parseCommand\",\n    value: function parseCommand(command) {\n      // Split the command into components by splitting on spaces,\n      // unless spaces are contained in quotation marks.\n      var components = command.match(/(?:[^\\s\"]+|\"[^\"]*\")+/g);\n      if (!components) {\n        throw new Error(\"Provided command: \\\"\".concat(command, \"\\\" could not be parsed.\"));\n      }\n      // Remove quotation marks from the beginning and end of each component if they are present.\n      for (var i = 0; i < components.length; i++) {\n        if (components[i][0] === '\"' && components[i].slice(-1) === '\"') {\n          components[i] = components[i].slice(1, -1);\n        }\n      }\n      return components;\n    }\n  }]);\n  return PluggableAuthHandler;\n}();\nexports.PluggableAuthHandler = PluggableAuthHandler;","map":null,"metadata":{},"sourceType":"script"}