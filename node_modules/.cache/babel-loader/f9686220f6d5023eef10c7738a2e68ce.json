{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2018 Google LLC\n *\n * Distributed under MIT license.\n * See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n */\nvar _objectSpread = require(\"/Users/shivampanwar/Desktop/GoFood/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread\");\nvar _regeneratorRuntime = require(\"/Users/shivampanwar/Desktop/GoFood/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\nvar _asyncToGenerator = require(\"/Users/shivampanwar/Desktop/GoFood/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\nvar _defineProperty = require(\"/Users/shivampanwar/Desktop/GoFood/my-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __exportStar = this && this.__exportStar || function (m, exports) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.requestTimeout = exports.setGCPResidency = exports.gcpResidencyCache = exports.resetIsAvailableCache = exports.isAvailable = exports.project = exports.instance = exports.HEADERS = exports.HEADER_VALUE = exports.HEADER_NAME = exports.SECONDARY_HOST_ADDRESS = exports.HOST_ADDRESS = exports.BASE_PATH = void 0;\nvar gaxios_1 = require(\"gaxios\");\nvar jsonBigint = require(\"json-bigint\");\nvar gcp_residency_1 = require(\"./gcp-residency\");\nexports.BASE_PATH = '/computeMetadata/v1';\nexports.HOST_ADDRESS = 'http://169.254.169.254';\nexports.SECONDARY_HOST_ADDRESS = 'http://metadata.google.internal.';\nexports.HEADER_NAME = 'Metadata-Flavor';\nexports.HEADER_VALUE = 'Google';\nexports.HEADERS = Object.freeze(_defineProperty({}, exports.HEADER_NAME, exports.HEADER_VALUE));\n/**\n * Returns the base URL while taking into account the GCE_METADATA_HOST\n * environment variable if it exists.\n *\n * @returns The base URL, e.g., http://169.254.169.254/computeMetadata/v1.\n */\nfunction getBaseUrl(baseUrl) {\n  if (!baseUrl) {\n    baseUrl = process.env.GCE_METADATA_IP || process.env.GCE_METADATA_HOST || exports.HOST_ADDRESS;\n  }\n  // If no scheme is provided default to HTTP:\n  if (!/^https?:\\/\\//.test(baseUrl)) {\n    baseUrl = \"http://\".concat(baseUrl);\n  }\n  return new URL(exports.BASE_PATH, baseUrl).href;\n}\n// Accepts an options object passed from the user to the API. In previous\n// versions of the API, it referred to a `Request` or an `Axios` request\n// options object.  Now it refers to an object with very limited property\n// names. This is here to help ensure users don't pass invalid options when\n// they  upgrade from 0.4 to 0.5 to 0.8.\nfunction validate(options) {\n  Object.keys(options).forEach(function (key) {\n    switch (key) {\n      case 'params':\n      case 'property':\n      case 'headers':\n        break;\n      case 'qs':\n        throw new Error(\"'qs' is not a valid configuration option. Please use 'params' instead.\");\n      default:\n        throw new Error(\"'\".concat(key, \"' is not a valid configuration option.\"));\n    }\n  });\n}\nfunction metadataAccessor(_x, _x2) {\n  return _metadataAccessor.apply(this, arguments);\n}\nfunction _metadataAccessor() {\n  _metadataAccessor = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(type, options) {\n    var noResponseRetries,\n      fastFail,\n      property,\n      requestMethod,\n      res,\n      err,\n      _args = arguments;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          noResponseRetries = _args.length > 2 && _args[2] !== undefined ? _args[2] : 3;\n          fastFail = _args.length > 3 && _args[3] !== undefined ? _args[3] : false;\n          options = options || {};\n          if (typeof options === 'string') {\n            options = {\n              property: options\n            };\n          }\n          property = '';\n          if (typeof options === 'object' && options.property) {\n            property = '/' + options.property;\n          }\n          validate(options);\n          _context.prev = 7;\n          requestMethod = fastFail ? fastFailMetadataRequest : gaxios_1.request;\n          _context.next = 11;\n          return requestMethod({\n            url: \"\".concat(getBaseUrl(), \"/\").concat(type).concat(property),\n            headers: Object.assign({}, exports.HEADERS, options.headers),\n            retryConfig: {\n              noResponseRetries: noResponseRetries\n            },\n            params: options.params,\n            responseType: 'text',\n            timeout: requestTimeout()\n          });\n        case 11:\n          res = _context.sent;\n          if (!(res.headers[exports.HEADER_NAME.toLowerCase()] !== exports.HEADER_VALUE)) {\n            _context.next = 16;\n            break;\n          }\n          throw new Error(\"Invalid response from metadata service: incorrect \".concat(exports.HEADER_NAME, \" header.\"));\n        case 16:\n          if (res.data) {\n            _context.next = 18;\n            break;\n          }\n          throw new Error('Invalid response from the metadata service');\n        case 18:\n          if (!(typeof res.data === 'string')) {\n            _context.next = 25;\n            break;\n          }\n          _context.prev = 19;\n          return _context.abrupt(\"return\", jsonBigint.parse(res.data));\n        case 23:\n          _context.prev = 23;\n          _context.t0 = _context[\"catch\"](19);\n        case 25:\n          return _context.abrupt(\"return\", res.data);\n        case 28:\n          _context.prev = 28;\n          _context.t1 = _context[\"catch\"](7);\n          err = _context.t1;\n          if (err.response && err.response.status !== 200) {\n            err.message = \"Unsuccessful response status code. \".concat(err.message);\n          }\n          throw _context.t1;\n        case 33:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee, null, [[7, 28], [19, 23]]);\n  }));\n  return _metadataAccessor.apply(this, arguments);\n}\nfunction fastFailMetadataRequest(_x3) {\n  return _fastFailMetadataRequest.apply(this, arguments);\n}\n/**\n * Obtain metadata for the current GCE instance\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _fastFailMetadataRequest() {\n  _fastFailMetadataRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(options) {\n    var secondaryOptions, responded, r1, r2;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          secondaryOptions = _objectSpread({}, options, {\n            url: options.url.replace(getBaseUrl(), getBaseUrl(exports.SECONDARY_HOST_ADDRESS))\n          }); // We race a connection between DNS/IP to metadata server. There are a couple\n          // reasons for this:\n          //\n          // 1. the DNS is slow in some GCP environments; by checking both, we might\n          //    detect the runtime environment signficantly faster.\n          // 2. we can't just check the IP, which is tarpitted and slow to respond\n          //    on a user's local machine.\n          //\n          // Additional logic has been added to make sure that we don't create an\n          // unhandled rejection in scenarios where a failure happens sometime\n          // after a success.\n          //\n          // Note, however, if a failure happens prior to a success, a rejection should\n          // occur, this is for folks running locally.\n          //\n          responded = false;\n          r1 = (0, gaxios_1.request)(options).then(function (res) {\n            responded = true;\n            return res;\n          }).catch(function (err) {\n            if (responded) {\n              return r2;\n            } else {\n              responded = true;\n              throw err;\n            }\n          });\n          r2 = (0, gaxios_1.request)(secondaryOptions).then(function (res) {\n            responded = true;\n            return res;\n          }).catch(function (err) {\n            if (responded) {\n              return r1;\n            } else {\n              responded = true;\n              throw err;\n            }\n          });\n          return _context2.abrupt(\"return\", Promise.race([r1, r2]));\n        case 5:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _fastFailMetadataRequest.apply(this, arguments);\n}\nfunction instance(options) {\n  return metadataAccessor('instance', options);\n}\nexports.instance = instance;\n/**\n * Obtain metadata for the current GCP Project.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction project(options) {\n  return metadataAccessor('project', options);\n}\nexports.project = project;\n/*\n * How many times should we retry detecting GCP environment.\n */\nfunction detectGCPAvailableRetries() {\n  return process.env.DETECT_GCP_RETRIES ? Number(process.env.DETECT_GCP_RETRIES) : 0;\n}\nvar cachedIsAvailableResponse;\n/**\n * Determine if the metadata server is currently available.\n */\nfunction isAvailable() {\n  return _isAvailable.apply(this, arguments);\n}\nfunction _isAvailable() {\n  _isAvailable = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n    var err, code;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          _context3.prev = 0;\n          // If a user is instantiating several GCP libraries at the same time,\n          // this may result in multiple calls to isAvailable(), to detect the\n          // runtime environment. We use the same promise for each of these calls\n          // to reduce the network load.\n          if (cachedIsAvailableResponse === undefined) {\n            cachedIsAvailableResponse = metadataAccessor('instance', undefined, detectGCPAvailableRetries(),\n            // If the default HOST_ADDRESS has been overridden, we should not\n            // make an effort to try SECONDARY_HOST_ADDRESS (as we are likely in\n            // a non-GCP environment):\n            !(process.env.GCE_METADATA_IP || process.env.GCE_METADATA_HOST));\n          }\n          _context3.next = 4;\n          return cachedIsAvailableResponse;\n        case 4:\n          return _context3.abrupt(\"return\", true);\n        case 7:\n          _context3.prev = 7;\n          _context3.t0 = _context3[\"catch\"](0);\n          err = _context3.t0;\n          if (process.env.DEBUG_AUTH) {\n            console.info(err);\n          }\n          if (!(err.type === 'request-timeout')) {\n            _context3.next = 13;\n            break;\n          }\n          return _context3.abrupt(\"return\", false);\n        case 13:\n          if (!(err.response && err.response.status === 404)) {\n            _context3.next = 17;\n            break;\n          }\n          return _context3.abrupt(\"return\", false);\n        case 17:\n          if (!(err.response && err.response.status === 404) && (\n          // A warning is emitted if we see an unexpected err.code, or err.code\n          // is not populated:\n          !err.code || !['EHOSTDOWN', 'EHOSTUNREACH', 'ENETUNREACH', 'ENOENT', 'ENOTFOUND', 'ECONNREFUSED'].includes(err.code))) {\n            code = 'UNKNOWN';\n            if (err.code) code = err.code;\n            process.emitWarning(\"received unexpected error = \".concat(err.message, \" code = \").concat(code), 'MetadataLookupWarning');\n          }\n          // Failure to resolve the metadata service means that it is not available.\n          return _context3.abrupt(\"return\", false);\n        case 19:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3, null, [[0, 7]]);\n  }));\n  return _isAvailable.apply(this, arguments);\n}\nexports.isAvailable = isAvailable;\n/**\n * reset the memoized isAvailable() lookup.\n */\nfunction resetIsAvailableCache() {\n  cachedIsAvailableResponse = undefined;\n}\nexports.resetIsAvailableCache = resetIsAvailableCache;\n/**\n * A cache for the detected GCP Residency.\n */\nexports.gcpResidencyCache = null;\n/**\n * Sets the detected GCP Residency.\n * Useful for forcing metadata server detection behavior.\n *\n * Set `null` to autodetect the environment (default behavior).\n */\nfunction setGCPResidency() {\n  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  exports.gcpResidencyCache = value !== null ? value : (0, gcp_residency_1.detectGCPResidency)();\n}\nexports.setGCPResidency = setGCPResidency;\n/**\n * Obtain the timeout for requests to the metadata server.\n *\n * In certain environments and conditions requests can take longer than\n * the default timeout to complete. This function will determine the\n * appropriate timeout based on the environment.\n *\n * @returns {number} a request timeout duration in milliseconds.\n */\nfunction requestTimeout() {\n  // Detecting the residency can be resource-intensive. Let's cache the result.\n  if (exports.gcpResidencyCache === null) {\n    exports.gcpResidencyCache = (0, gcp_residency_1.detectGCPResidency)();\n  }\n  return exports.gcpResidencyCache ? 0 : 3000;\n}\nexports.requestTimeout = requestTimeout;\n__exportStar(require(\"./gcp-residency\"), exports);","map":null,"metadata":{},"sourceType":"script"}